package lexer;
import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import ast.*;

parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    private List<ASTNode> list(){
            return new ArrayList<ASTNode>();
    }

    private List<ASTNode> list(ASTNode e1){
        return new ArrayList<ASTNode>(){{add(e1);}};
    }

    private List<ASTNode> list(ASTNode e1, ASTNode e2){
            return new ArrayList<ASTNode>(){{add(e1); add(e2);}};
    }

    private List<ASTNode> list(ASTNode e1, ASTNode e2, ASTNode e3){
        return new ArrayList<ASTNode>(){{add(e1); add(e2); add(e3);}};
    }
    private List<ASTNode> list(ASTNode e1, ASTNode e2, ASTNode e3, ASTNode e4){
        return new ArrayList<ASTNode>(){{add(e1); add(e2); add(e3); add(e4);}};
    }
    private List<ASTNode> list(ASTNode e1, ASTNode e2, ASTNode e3, ASTNode e4, ASTNode e5){
            return new ArrayList<ASTNode>(){{add(e1); add(e2); add(e3); add(e4); add(e5);}};
    }
    private List<ASTNode> addList(ASTNode e1, ASTNode e2){  // add e2 to e1's children, then return e1's children
        System.out.println("Begin current node is " + e1 + " add node " + e2);
        List<ASTNode> children = e1.children;
        children.add(e2);
        System.out.println("Done current node is " + e1 + " add node " + e2);
        return children;
    }
:};

/** Terminals */

terminal Token                  ID;

// Literals
terminal    Token/* IntegerLiteral*/         INTGERLITERAL;
terminal    Token/* CharLiteral */           CHARLITERAL;
terminal    Token/* StringLiteral */         STRINGLITERAL;
terminal    Token/* NullLiteral */          NULLLITERAL;
terminal    Token/* ThisLiteral */            THISLITERAL;
terminal    Token/* TrueLiteral */           TRUELITERAL;
terminal    Token/* FalseLiteral */          FALSELITERAL;

// Type
terminal Token                  VOID, BOOL, INT, CHAR, BYTE, SHORT; // how to represent Array?

// OP
terminal Token                  PLUS, MINUS, DIVIDES, MOD, STAR; //Arithmatic OP
terminal Token                  BINARYAND, BINARYOR, NOT; // logic OP
terminal Token                  EQ, LT, LE, GT, GE, NE;  // Comp OP
terminal Token                  BITWISEAND, BITWISEOR; // bitwise OP
terminal Token                  ASSIGN, NEW, INSTANCEOF;    // other

// Symbols
terminal Token                  LEFTPARN, RIGHTPARN, LEFTBRACKET, RIGHTBARCKET,LEFTCURLY, RIGHTCURLY; // ()[]{}
terminal Token                  COMMA, DOT, SEMICOLUMN; // ,.

// Keywords
terminal Token                  FOR, WHILE, IF, ELSE, RETURN, NATIVE, PACKAGE, IMPORT; //program keywords
terminal Token                  CLASS, INTERFACE, ABSTRACT, PUBLIC, PROTECTED, STATIC, EXTENDS, IMPLEMENTS, SUPER, FINAL; // class keywords

/** Non-terminals **/
non terminal  CompilationUnit                   compilation_unit;   // the goal of joos
non terminal  TypeDecls                  type_decls;
non terminal  TypeDecl                  type_decl;
non terminal  ImportDecls                  import_decls;    // import java...
non terminal  ImportDecl                  import_decl;
non terminal  PackageDecl                  package_decl;   // package cs444.a1...
non terminal  SingleTypeImportDecl                  single_type_import_decl;
non terminal  TypeImportOndemandDecl                  type_import_ondemand_decl;


// modifiers
nonterminal  Modifiers             modifiers;
nonterminal  Token                 modifier;



// class
non terminal    ClassDecl                    class_decl; // class modifiers class identifier Super interface classbody
non terminal    InterfaceDecl                    interface_decl;
non terminal    Super                    Super; // Super: extends ClassType;
non terminal    Interfaces                    interfaces; // : implements InterfaceTypeList
non terminal    ClassBody                    class_body;     // {class_body_decls}
non terminal    ClassBodyDecls                class_body_decls;
non terminal    ClassBodyDecl                class_body_decl;
non terminal    ClassMemberDecl                class_member_decl;
non terminal    ConstructorDecl                constructor_decl; // one of class_body_decl;
non terminal    FieldDecl                field_decl;
non terminal    MethodDecl                 method_decl; // ++ class_decl, interface_decl be one of class_member_decl;
non terminal    InterfaceBody                interface_body; // {interface_member_decl}
non terminal    InterfaceMemberDecls                interface_member_decls;
non terminal    InterfaceMemberDecl                interface_member_decl; //  one of abstract_method_decl, class_decl, interface_decl;
non terminal    AbstractMethodDecl                abstract_method_decl;   // optional abstract + methoddeclar
non terminal    ExtendsInterfaces                extends_interfaces;


// method
non terminal   ConstructorDeclarator                 constructor_declarator;
non terminal   ConstructorBody                 constructor_body;
non terminal   MethodHeader                 method_header;
non terminal   MethodBody                 method_body;
non terminal   MethodDeclarator                 method_declarator;

// type
non terminal    Type                 type;       // int, int[]
non terminal    ClassOrInterfaceType                    class_type;
non terminal    ClassOrInterfaceType                    interface_type;
non terminal    InterfaceTypeList                    interface_typelist;
non terminal    PrimitiveType                    primitive_type;
non terminal    NumericType                    numeric_type;
non terminal    ReferenceType                    reference_type;
non terminal    ClassOrInterfaceType                    class_or_interface_type;
non terminal    ArrayType                    array_type; // Type []
non terminal    Dims                dims;



// statements (side effects)
non terminal    Block                block; // {block_statement[opt]}
non terminal    BlockStmts                block_statements;
non terminal    BlockStmt                block_statement;    // one of statement, class decl, local_var_decl
non terminal    LocalVarDeclStmt                local_var_decl_statement; // local_var_decl + ;
non terminal    LocalVarDecl                local_var_decl;
non terminal    VarDeclarators                var_declarators;
non terminal    VarDeclarator                var_declarator;
non terminal    VarDeclaratorID                var_declarator_id;
non terminal    Stmt                statement;
non terminal    StmtNotIf                statement_no_short_if;
non terminal    StmtWithoutSubstmt                statement_without_trailing_substatement;
non terminal    IfThenStmt                if_then_statement;
non terminal    IfThenElseStmt                if_then_else_statement;
non terminal    IfThenElseStmtNotIf                if_then_else_statement_no_short_if;
non terminal    ForStmt                for_statement;
non terminal    ForStmtNotIf                for_statement_no_short_if;
non terminal    ForInit                for_init;
non terminal    ForUpdate                for_update;
non terminal    WhileStmt                while_statement;
non terminal    WhileStmtNotIf                while_statement_no_short_if;
non terminal    ReturnStmt                return_statement;
non terminal    EmptyStmt                empty_statement; //;

// evaluate the expression, if it has a value, than it's discard

non terminal    ExprStmt                expression_statement; // expression_statement = statement_expression + ;
non terminal    StmtExpr                statement_expression;
non terminal    StmtExprList                statement_expression_list; // seperate statement_expression by ','
non terminal    AssignmentExpr                assignment_expr; //
non terminal    Assignment                assignment;

// experssions (have values) and always use return value
non terminal    Expr                expr;           // any statement that returns a value
non terminal    CastExpr                cast_expr;
non terminal    ArrayAccess                array_access;
non terminal    ArrayCreationExpr                array_creation_expr;
non terminal    FieldAccess                field_access;   //{...}.ID
non terminal    ClassInstanceCreateExpr                class_instance_creation_expression;
non terminal    Primary                primary;
non terminal    PrimaryNoArray      primary_no_new_array; // simplest kinds of expressions that evaluate first
non terminal    Literal                literal;    // 123, "abc"
non terminal    MethodInvocation                method_invocation;
non terminal    UnaryExpr                unary_expr;   // -, +
non terminal    UnaryExprNotPlusMinus                unary_expr_not_plus_minus; // !, cast
non terminal    PostFixExpr                post_fix_expr;
non terminal    MultiplicativeExpr                multiplicative_expr; // *, / %
non terminal    AdditiveExpr                additive_expr;  // +, -
non terminal    RelationExpr                relation_expr;  // >, <, = instanceof
non terminal    EqualityExpr                equality_expr; // ==, !=
non terminal    AndExpr                and_expr; // &
non terminal    OrExpr                or_expr; // |
non terminal    ConditionalAndExpr                conditional_and_expr;
non terminal    ConditionalOrExpr                conditional_or_expr;
non terminal    LHS                lhs;        // left hand side: ambiguous_name, field_access, array_access
non terminal    DimExpr                dim_expr;

// parameters/arguments
non terminal    ParameterList                parameter_list;
non terminal    Parameter                paramater;
non terminal    ArgumentList                argument_list;

// Name
non terminal      Name               name;





/** Precedence */

start with compilation_unit;

/** ============= GRAMMAR ============= */

// start
compilation_unit ::= | package_decl:e1 {:RESULT = new CompilationUnit(list(e1, null, null), "");  :}
                    | import_decls:e2  {:RESULT = new CompilationUnit(list(null, e2, null), "");  :}
                    | type_decls:e3 {:RESULT = new CompilationUnit(list(null, null, e3), "");  :}
                    | package_decl:e1 import_decls:e2 {:RESULT = new CompilationUnit(list(e1, e2, null), "");  :}
                    | package_decl:e1 type_decls:e3 {:RESULT =  new CompilationUnit(list(e1, null, e3), "");  :}
                    | import_decls:e2 type_decls:e3 {:RESULT = new CompilationUnit(list(null, e2, e3), "");  :}
                    | package_decl:e1 import_decls:e2 type_decls:e3 {:RESULT = new CompilationUnit(list(e1, e2, e3), "");  :};


import_decls ::=  import_decl:e1 {:RESULT = new ImportDecls(list(e1), "");  :}
                    | import_decls:e1 import_decl:e2 {:RESULT = new ImportDecls(addList(e1, e2), "");:};

import_decl ::= single_type_import_decl:e {:RESULT = e; :}
                    | type_import_ondemand_decl:e {:RESULT = e; :};

single_type_import_decl ::= IMPORT name:e SEMICOLUMN {:RESULT = new SingleTypeImportDecl(list(e), "");:};

type_import_ondemand_decl ::= IMPORT name:e DOT STAR SEMICOLUMN {:RESULT = new TypeImportOndemandDecl(list(e), "");:};

type_decls ::=  type_decls:e1 type_decl:e2 {:RESULT = new TypeDecls(addList(e1, e2), "");:}
                | type_decl: e1 {:RESULT = new TypeDecls(list(e1), "");:};

type_decl ::= class_decl:e {:RESULT = e; :}
            | interface_decl:e {:RESULT = e; :}
            | SEMICOLUMN {:RESULT = null; :};

package_decl    ::=  PACKAGE name:e1 SEMICOLUMN {:RESULT = new PackageDecl(list(e1), ""); :};

name ::= ID:e1 {:RESULT = new Name(list(e1), "");:}
        | name:e1 DOT ID:e2 {:RESULT = new Name(addList(e1, e2), "");:};




// Statements

block ::= LEFTCURLY block_statements:e RIGHTCURLY {:RESULT = new Block(list(e), "");:}
        | LEFTCURLY RIGHTCURLY {:RESULT = new Block(list(null), "");:};

block_statements ::= block_statements:e1 block_statement:e2 {:RESULT = new BlockStmts(addList(e1, e2), "");:}
                    | block_statement:e {:RESULT = new BlockStmts(list(e), "");:};

// not sure
block_statement ::= local_var_decl_statement:e {:RESULT = e;:}
                    | statement:e {:RESULT = e;:}/**{:RESULT = new Block(list(e), "");:}*/;

local_var_decl_statement  ::= local_var_decl:e SEMICOLUMN {:RESULT = e;:};

local_var_decl  ::= type:e1 var_declarators:e2 {:RESULT = new LocalVarDecl(list(e1, e2), "");:};

var_declarators ::= var_declarator:e  {:RESULT = new VarDeclarators(list(e), "");:}
                    | var_declarators:e1 COMMA var_declarator:e2 {:RESULT = new VarDeclarators(addList(e1, e2), "");:};

var_declarator ::= var_declarator_id:e {:RESULT = new VarDeclarator(list(e, null), "");:}
                    | var_declarator_id:e1 ASSIGN expr:e2 {:RESULT = new VarDeclarator(list(e1, e2), "");:};

var_declarator_id ::= ID:e {:RESULT = new VarDeclaratorID(list(e), "");:};

statement ::= statement_without_trailing_substatement:e {:RESULT = e;:}
            | if_then_statement:e {:RESULT = e;:}
            | if_then_else_statement:e {:RESULT = e;:}
            | while_statement:e {:RESULT = e;:}
            | for_statement:e {:RESULT = e;:};

statement_without_trailing_substatement ::= block:e {:RESULT = e;:}   // single statement
                                            | empty_statement:e {:RESULT = e;:}
                                            | expression_statement:e {:RESULT = e;:}
                                            | return_statement:e {:RESULT = e;:};

statement_no_short_if ::= statement_without_trailing_substatement:e {:RESULT = new StmtNotIf(list(e), "");:}
                        | if_then_else_statement_no_short_if:e {:RESULT = e;:}
                        | while_statement_no_short_if:e {:RESULT = e;:}
                        | for_statement_no_short_if:e {:RESULT = e;:};

empty_statement ::= SEMICOLUMN {:RESULT = new EmptyStmt(list(), "");:};
// not sure
expression_statement ::= statement_expression:e SEMICOLUMN {:RESULT = new ExprStmt(list(e), "");:};

statement_expression ::= assignment:e {:RESULT = new StmtExpr(list(e), "");:}
                        | method_invocation:e {:RESULT = new StmtExpr(list(e), "");:}
                        | class_instance_creation_expression:e {:RESULT = new StmtExpr(list(e), "");:};


// if statement

if_then_statement ::= IF LEFTPARN expr:e1 RIGHTPARN statement:e2 {:RESULT = new IfThenStmt(list(e1, e2), "");:};

if_then_else_statement ::= IF LEFTPARN expr:e1 RIGHTPARN statement_no_short_if:e2 ELSE statement:e3 {:RESULT = new IfThenElseStmt(list(e1, e2, e3), "");:};

if_then_else_statement_no_short_if ::= IF LEFTPARN expr:e1 RIGHTPARN statement_no_short_if:e2 ELSE statement_no_short_if:e3 {:RESULT = new IfThenElseStmtNotIf(list(e1, e2, e3), "");:};

// while statement
while_statement ::= WHILE LEFTPARN expr:e1 RIGHTPARN statement:e2 {:RESULT = new WhileStmt(list(e1, e2), "");:};

while_statement_no_short_if ::= WHILE LEFTPARN expr:e1 RIGHTPARN statement_no_short_if:e2 {:RESULT = new WhileStmtNotIf(list(e1, e2), "");:};

// for statement
for_statement ::= FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(null, null, null, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(e1, null, null, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN expr:e2  SEMICOLUMN  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(null, e2, null, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN for_update:e3  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(null, null, e3, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN expr:e2  SEMICOLUMN  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(e1, e2, null, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN  SEMICOLUMN for_update:e3 RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(e1, null, e3, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN expr:e2 SEMICOLUMN for_update:e3 RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(null, e2, e3, e4), "");:}
                | FOR LEFTPARN for_init:e1  SEMICOLUMN expr:e2 SEMICOLUMN for_update:e3 RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(e1, e2, e3, e4), "");:};

for_statement_no_short_if ::= FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(null, null, null, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(e1, null, null, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN expr:e2  SEMICOLUMN  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(null, e2, null, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN for_update:e3  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(null, null, e3, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN expr:e2  SEMICOLUMN  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(e1, e2, null, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN  SEMICOLUMN for_update:e3 RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(e1, null, e3, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN expr:e2 SEMICOLUMN for_update:e3 RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(null, e2, e3, e4), "");:}
                | FOR LEFTPARN for_init:e1  SEMICOLUMN expr:e2 SEMICOLUMN for_update:e3 RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(e1, e2, e3, e4), "");:};

for_init ::=  type:e1 var_declarator:e2 {:RESULT = new ForInit(list(e1, e2), "");:}
            | statement_expression:e1 {:RESULT = new ForInit(list(e1, null), "");:};

for_update ::=  statement_expression:e {:RESULT = new ForUpdate(list(e), "");:};

statement_expression_list ::= statement_expression:e {:RESULT = new StmtExprList(list(e), "");:}
                            | statement_expression_list:e1 COMMA statement_expression:e2 {:RESULT = new StmtExprList(addList(e1, e2), "");:};

return_statement ::= RETURN expr:e SEMICOLUMN {:RESULT = new ReturnStmt(list(e), "");:}
                    | RETURN SEMICOLUMN {:RESULT = new ReturnStmt(list(null), "");:};

// expressions
dim_expr ::= LEFTBRACKET expr:e RIGHTBARCKET {:RESULT = new DimExpr(list(e), "");:};

primary ::= primary_no_new_array:e {:RESULT = e;:}
            | array_creation_expr:e {:RESULT = e;:};

array_creation_expr ::= NEW primitive_type:e1 dim_expr:e2 {:RESULT = new ArrayCreationExpr(list(e1, e2), "");:}
                    |  NEW class_or_interface_type:e1 dim_expr:e2 {:RESULT = new ArrayCreationExpr(list(e1, e2), "");:};



primary_no_new_array ::= literal:e {:RESULT = e;:}
                         | THISLITERAL:e {:RESULT = new PrimaryNoArray(list(e), "");:}
                         | LEFTPARN expr:e RIGHTPARN {:RESULT = new PrimaryNoArray(list(e), "");:}
                         | class_instance_creation_expression:e {:RESULT = e;:}
                         | field_access:e {:RESULT = e;:}
                         | method_invocation:e {:RESULT = e;:}
                         | array_access:e {:RESULT = e;:};


literal ::= INTGERLITERAL:e {:RESULT = new Literal(list(e), "");:}
            | TRUELITERAL:e {:RESULT = new Literal(list(e), "");:}
            | FALSELITERAL:e {:RESULT = new Literal(list(e), "");:}
            | CHARLITERAL:e {:RESULT = new Literal(list(e), "");:}
            | STRINGLITERAL:e {:RESULT = new Literal(list(e), "");:}
            | NULLLITERAL:e {:RESULT = new Literal(list(e), "");:};

class_instance_creation_expression ::= NEW class_or_interface_type:e1 LEFTPARN argument_list:e2 RIGHTPARN {:RESULT = new ClassInstanceCreateExpr(list(e1, e2), "");:}
                                    |  NEW class_or_interface_type:e1 LEFTPARN RIGHTPARN {:RESULT = new ClassInstanceCreateExpr(list(e1, null), "");:};

argument_list ::=  expr:e1 {:RESULT = new ArgumentList(list(e1), "");:}
                | argument_list:e1 COMMA expr:e2 {:RESULT = new ArgumentList(addList(e1, e2), "");:};


array_access ::= name:e1 dim_expr:e2 {:RESULT = new ArrayAccess(list(e1, e2), "");:}
                | primary_no_new_array:e1 dim_expr:e2 {:RESULT = new ArrayAccess(list(e1, e2), "");:};

field_access ::= primary:e1 DOT ID:e2 {:RESULT = new FieldAccess(list(e1, e2), "");:};

method_invocation ::= name:e1 LEFTPARN argument_list:e3 RIGHTPARN {:RESULT = new MethodInvocation(list(e1, null, e3), "");:}
                    | name:e1 LEFTPARN  RIGHTPARN {:RESULT = new MethodInvocation(list(e1, null, null), "");:}
                    | primary:e1 DOT ID:e2 LEFTPARN argument_list:e3 RIGHTPARN {:RESULT = new MethodInvocation(list(e1, e2, e3), "");:}
                    | primary:e1 DOT ID:e2 LEFTPARN  RIGHTPARN {:RESULT = new MethodInvocation(list(e1, e2, null), "");:};
// Not sure for the 3 below
post_fix_expr ::= primary:e {:RESULT = e;:}
                  | name:e {:RESULT = new PostFixExpr(list(e), "");:};

unary_expr  ::=  unary_expr_not_plus_minus:e {:RESULT = e;:}
                | MINUS:e1 unary_expr:e2 {:RESULT = new UnaryExpr(list(e1, e2), "");:};

unary_expr_not_plus_minus   ::= NOT:e1 unary_expr:e2 {:RESULT = new UnaryExprNotPlusMinus(list(e1, e2), "");:}
                            |   cast_expr:e {:RESULT = e;:}
                            | post_fix_expr:e {:RESULT = e;:};

cast_expr   ::= LEFTPARN primitive_type:e1 RIGHTPARN unary_expr:e3 {:RESULT = new CastExpr(list(e1, null, e3), "");:}
                | LEFTPARN expr:e1 RIGHTPARN unary_expr_not_plus_minus:e3 {:RESULT = new CastExpr(list(e1, null, e3), "");:}
                | LEFTPARN primitive_type:e1 dims:e2 RIGHTPARN unary_expr:e3 {:RESULT = new CastExpr(list(e1, e2, e3), "");:}
                | LEFTPARN name:e1 dims:e2 RIGHTPARN unary_expr_not_plus_minus:e3 {:RESULT = new CastExpr(list(e1, e2, e3), "");:};

multiplicative_expr ::= unary_expr:e {:RESULT = e;:}
                    |   multiplicative_expr:e1 STAR:e2 unary_expr:e3 {:RESULT = new MultiplicativeExpr(list(e1, e2, e3), "");:}
                    |   multiplicative_expr:e1 DIVIDES:e2 unary_expr:e3 {:RESULT = new MultiplicativeExpr(list(e1, e2, e3), "");:}
                    |   multiplicative_expr:e1 MOD:e2 unary_expr:e3 {:RESULT = new MultiplicativeExpr(list(e1, e2, e3), "");:};

additive_expr ::= multiplicative_expr:e {:RESULT = e;:}
                | additive_expr:e1 PLUS:e2 multiplicative_expr:e3 {:RESULT = new AdditiveExpr(list(e1, e2, e3), "");:}
                | additive_expr:e1 MINUS:e2 multiplicative_expr:e3 {:RESULT = new AdditiveExpr(list(e1, e2, e3), "");:};

relation_expr ::= additive_expr:e {:RESULT = e;:}
                | relation_expr:e1 LT:e2 additive_expr:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:}
                | relation_expr:e1 GT:e2 additive_expr:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:}
                | relation_expr:e1 LE:e2 additive_expr:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:}
                | relation_expr:e1 GE:e2 additive_expr:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:}
                | relation_expr:e1 INSTANCEOF:e2 reference_type:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:};

equality_expr ::= relation_expr:e {:RESULT = e;:}
                | equality_expr:e1 EQ:e2 relation_expr:e3 {:RESULT = new EqualityExpr(list(e1, e2, e3), "");:}
                | equality_expr:e1 NE:e2 relation_expr:e3 {:RESULT = new EqualityExpr(list(e1, e2, e3), "");:};

and_expr ::= equality_expr:e {:RESULT = e;:}
            | and_expr:e1 BITWISEAND equality_expr:e2 {:RESULT = new AndExpr(list(e1, e2), "");:};

or_expr ::= and_expr:e {:RESULT = e;:}
          | or_expr:e1 BITWISEOR and_expr:e2 {:RESULT = new OrExpr(list(e1, e2), "");:};

conditional_and_expr ::= or_expr:e {:RESULT = e;:}
                        | conditional_and_expr:e1 BINARYAND or_expr:e2 {:RESULT = new ConditionalAndExpr(list(e1, e2), "");:};

conditional_or_expr ::= conditional_and_expr:e {:RESULT = e;:}
                        | conditional_or_expr:e1 BINARYOR conditional_and_expr:e2 {:RESULT = new ConditionalOrExpr(list(e1, e2), "");:};

assignment_expr ::= conditional_or_expr:e {:RESULT = e;:}
                |   assignment:e {:RESULT = e;:};

assignment ::= lhs:e1 ASSIGN assignment_expr:e2 {:RESULT = new Assignment(list(e1, e2), "");:};

lhs ::= name:e {:RESULT = new LHS(list(e), "");:}
        | field_access:e {:RESULT = new LHS(list(e), "");:}
        | array_access:e {:RESULT = new LHS(list(e), "");:};

expr ::= assignment_expr:e {:RESULT = e;:};


// type
dims ::= LEFTBRACKET RIGHTBARCKET;

type ::= primitive_type:e {:RESULT = e;:}
        | reference_type:e {:RESULT = e;:};



primitive_type ::= numeric_type:e {:RESULT = e;:}
                 | BOOL:e {:RESULT = new PrimitiveType(list(), e.value);:};

numeric_type ::= BYTE:e {:RESULT = new NumericType(list(e), e.value);:}
                | SHORT:e {:RESULT = new NumericType(list(), e.value);:}
                | INT:e {:RESULT = new NumericType(list(), e.value);:}
                | CHAR:e {:RESULT = new NumericType(list(), e.value);:};

reference_type ::= class_or_interface_type:e {:RESULT = e;:}
                |  array_type:e {:RESULT = e;:};

class_or_interface_type ::= name:e {:RESULT = new ClassOrInterfaceType(list(e), "");:};

class_type ::= class_or_interface_type:e {:RESULT = e;:};
interface_type ::= class_or_interface_type:e {:RESULT = e;:};

array_type ::= name:e dims  {:RESULT = new ArrayType(list(new ClassOrInterfaceType(list(e), "")), "");:}
            |  primitive_type:e dims {:RESULT = new ArrayType(list(e), "");:};


// class and interface
modifier ::= PUBLIC:e {:RESULT = e;:}
        | PROTECTED:e {:RESULT = e;:}
        | ABSTRACT:e {:RESULT = e;:}
        | NATIVE:e {:RESULT = e;:}
        | FINAL:e {:RESULT = e;:}
        | STATIC:e {:RESULT = e;:};

modifiers ::= modifier:e {:RESULT = new Modifiers(list(e), "");:}
           | modifiers:e1 modifier:e2 {:RESULT = new Modifiers(addList(e1,e2), "");:};

// class
class_decl ::= CLASS ID:e2 class_body:e5 {:RESULT = new ClassDecl(list(null, e2, null, null, e5), "");:}// identifier not found
               |
               modifiers:e1 CLASS ID:e2 class_body:e5 {:RESULT = new ClassDecl(list(e1, e2, null, null, e5), "");:}
               |
               modifiers:e1 CLASS ID:e2 Super:e3 class_body:e5 {:RESULT = new ClassDecl(list(e1, e2, e3, null, e5), "");:}
               |
               modifiers:e1 CLASS ID:e2 interfaces:e4 class_body:e5 {:RESULT = new ClassDecl(list(e1, e2, null, e4, e5), "");:}
               |
               modifiers:e1 CLASS ID:e2 Super:e3 interfaces:e4 class_body:e5 {:RESULT = new ClassDecl(list(e1, e2, e3, e4, e5), "");:}
               |
               CLASS ID:e2 Super:e3 class_body:e5 {:RESULT = new ClassDecl(list(null, e2, e3, null, e5), "");:}
               |
               CLASS ID:e2 Super:e3 interfaces:e4 class_body:e5 {:RESULT = new ClassDecl(list(null, e2, e3, e4, e5), "");:}
               |
               CLASS ID:e2 interfaces:e4 class_body:e5 {:RESULT = new ClassDecl(list(null, e2, null, e4, e5), "");:}
               ;


interface_decl ::= INTERFACE ID:e2 interface_body:e4 {:RESULT = new InterfaceDecl(list(null, e2, null, e4), "");:}
                   |
                   modifiers:e1 INTERFACE ID:e2 interface_body:e4 {:RESULT = new InterfaceDecl(list(e1, e2, null, e4), "");:}
                   |
                   INTERFACE ID:e2 extends_interfaces:e3 interface_body:e4 {:RESULT = new InterfaceDecl(list(null, e2, e3, e4), "");:}
                   |
                   modifiers:e1 INTERFACE ID:e2 extends_interfaces:e3 interface_body:e4 {:RESULT = new InterfaceDecl(list(e1, e2, e3, e4), "");:}
                   ;

extends_interfaces ::= EXTENDS interface_type:e {:RESULT = new ExtendsInterfaces(list(e), "");:}
                    |  extends_interfaces:e1 COMMA interface_type:e2 {:RESULT = new ExtendsInterfaces(addList(e1,e2), "");:};

Super ::= EXTENDS class_type:e {:RESULT = new Super(list(e), "");:};

interfaces ::= IMPLEMENTS  interface_typelist:e {:RESULT = new Interfaces(list(e), "");:};

interface_typelist ::= interface_type:e {:RESULT = new InterfaceTypeList(list(e), "");:}
                       |
                       interface_typelist:e1 COMMA interface_type:e2 {:RESULT = new InterfaceTypeList(addList(e1,e2), "");:}
                       ;


class_body ::= LEFTCURLY class_body_decls:e RIGHTCURLY {:RESULT = new ClassBody(list(e), "");:}
               |
               LEFTCURLY RIGHTCURLY {:RESULT = new ClassBody(list(null), "");:}
               ;

class_body_decls ::= class_body_decl:e {:RESULT = new ClassBodyDecls(list(e), "");:}
                     |
                     class_body_decls:e1 class_body_decl:e2 {:RESULT = new ClassBodyDecls(addList(e1,e2), "");:}
                     ;

class_body_decl ::= class_member_decl:e {:RESULT = e;:}
                    |
                    constructor_decl:e {:RESULT = e;:}
                    ;

class_member_decl ::= field_decl:e {:RESULT = e;:}
                      |
                      method_decl:e {:RESULT = e;:}
                      ;

constructor_decl ::= modifiers:e1 constructor_declarator:e2 constructor_body:e3 {:RESULT = new ConstructorDecl(list(e1,e2,e3),"");:}
                     |
                     constructor_declarator:e2 constructor_body:e3 {:RESULT = new ConstructorDecl(list(null,e2,e3),"");:}
                     ;

field_decl ::= modifiers:e1 type:e2 var_declarators:e3 SEMICOLUMN {:RESULT = new FieldDecl(list(e1,e2,e3), "");:} //TODO: replace null with e3
               |
               type:e1 var_declarators:e2 SEMICOLUMN {:RESULT = new FieldDecl(list(e1, e2, null), "");:}
               ;

// adding in 8.4
// is this delcaration or declarator cuz abstract_method_decl asking for declarator
method_decl ::= method_header:e1 method_body:e2 {:RESULT = new MethodDecl(list(e1,e2), "");:}; //TODO: replace null with e3
method_header ::=  modifiers:e1 type:e2 method_declarator:e3 {:RESULT = new MethodHeader(list(e1,e2, e3), "");:}
                |  modifiers:e1 VOID:e2 method_declarator:e3 {:RESULT = new MethodHeader(list(e1,e2, e3), "");:};

method_body ::= block:e  {:RESULT = new MethodBody(list(e), "");:} //TODO: replace null with e
                | SEMICOLUMN {:RESULT = new MethodBody(list(null), "");:};


method_declarator ::= ID:e1 LEFTPARN parameter_list:e2 RIGHTPARN {:RESULT = new MethodDeclarator(list(e1, e2), "");:}
                    | ID:e1 LEFTPARN RIGHTPARN {:RESULT = new MethodDeclarator(list(e1, null), "");:};

parameter_list ::=  paramater:e {:RESULT = new ParameterList(list(e), "");:}
                   | parameter_list:e1 COMMA paramater:e2 {:RESULT = new ParameterList(addList(e1, e2), "");:};

paramater ::= type:e1 var_declarator_id:e2 {:RESULT = new Parameter(list(e1, e2), "");:};


abstract_method_decl ::= modifiers:e1 type:e2 method_declarator:e3 {:RESULT = new AbstractMethodDecl(list(e1, e2, e3), "");:};


interface_body ::= LEFTCURLY interface_member_decls:e RIGHTCURLY {:RESULT = new InterfaceBody(list(e), "");:}
                   |
                   LEFTCURLY RIGHTCURLY {:RESULT = new InterfaceBody(list(null), "");:}
                   ;

interface_member_decls ::= interface_member_decl:e {:RESULT = new InterfaceMemberDecls(list(e), "");:}
                           |
                           interface_member_decls:e1 interface_member_decl:e2 {:RESULT = new InterfaceMemberDecls(addList(e1,e2), "");:}
                           ;
interface_member_decl ::= abstract_method_decl:e  {:RESULT = e;:}
                          ;


constructor_declarator ::= ID:e1 LEFTPARN parameter_list:e2 RIGHTPARN {:RESULT = new ConstructorDeclarator(list(e1, e2), "");:}
                           |
                           ID:e1 LEFTPARN RIGHTPARN {:RESULT = new ConstructorDeclarator(list(e1, null), "");:}
                           ;
constructor_body ::= LEFTCURLY block_statements:e RIGHTCURLY {:RESULT = new ConstructorBody(list(e), "");:}
                     |
                     LEFTCURLY RIGHTCURLY {:RESULT = new ConstructorBody(list(null), "");:};


