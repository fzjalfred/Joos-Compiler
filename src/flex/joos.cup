import java_cup.runtime.*;
import java.util.*;
import java.io.*;

parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

/** Terminals */

terminal Token                  ID;

// Literals
terminal /* IntegerLiteral*/         INTGERLITERAL;
terminal /* CharLiteral */           CHARLITERAL;
terminal /* StringLiteral */         STRINGLITERAL;
terminal /* NullLiteral */          NULLLITERAL;
terminal /* ThisLiteral */            THISLITERAL;
terminal /* TrueLiteral */           TRUELITERAL;
terminal /* FalseLiteral */          FALSELITERAL;

// Type
terminal Token                  VOID, BOOL, INT, CHAR, BYTE, SHORT; // how to represent Array?

// OP
terminal Token                  PLUS, MINUS, DIVIDES, MOD, STAR; //Arithmatic OP
terminal Token                  BINARYAND, BINARYOR, NOT; // logic OP
terminal Token                  EQ, LT, LE, GT, GE, NE;  // Comp OP
terminal Token                  BITWISEAND, BITWISEOR; // bitwise OP
terminal Token                  ASSIGN, NEW, INSTANCEOF;    // other

// Symbols
terminal Token                  LEFTPARN, RIGHTPARN, LEFTBRACKET, RIGHTBARCKET,LEFTCURLY, RIGHTCURLY; // ()[]{}
terminal Token                  COMMA, DOT, SEMICOLUMN; // ,.

// Keywords
terminal Token                  FOR, WHILE, IF, ELSE, RETURN, NATIVE, PACKAGE, IMPORT; //program keywords
terminal Token                  CLASS, INTERFACE, ABSTRACT, PUBLIC, PROTECTED, STATIC, EXTENDS, IMPLEMENTS, SUPER, FINAL; // class keywords

/** Non-terminals **/
non terminal                    compilation_unit;   // the goal of joos
non terminal                    type_decls;
non terminal                    type_decl;
non terminal                    import_decls;    // import java...
non terminal                    import_decl;
non terminal                    package_decl;   // package cs444.a1...
non terminal                    single_type_import_decl;
non terminal                    type_import_ondemand_decl;


// modifiers
nonterminal                     modifiers;
nonterminal                     access_modifier, nonaccess_modifier;
nonterminal                     modifier;



// class
non terminal                    class_decl; // class modifiers class identifier Super interface classbody
non terminal                    interface_decl;
non terminal                    Super; // Super: extends ClassType;
non terminal                    interfaces; // : implements InterfaceTypeList
non terminal                    class_body;     // {class_body_decls}
non terminal                    class_body_decls, class_body_decl;
non terminal                    class_member_decl, constructor_decl; // one of class_body_decl;
non terminal                    field_decl, method_decl; // ++ class_decl, interface_decl be one of class_member_decl;
non terminal                    interface_body; // {interface_member_decl}
non terminal                    interface_member_decls;
non terminal                    interface_member_decl; //  one of abstract_method_decl, class_decl, interface_decl;
non terminal                    abstract_method_decl;   // optional abstract + methoddeclar
non terminal                    extends_interfaces;


// method
non terminal                    constructor_declarator;
non terminal                    constructor_body;
non terminal                    method_header;
non terminal                    method_body;
non terminal                    method_declarator;

// type
non terminal                    type;       // int, int[]
non terminal                    class_type;
non terminal                    interface_type;
non terminal                    interface_typelist;
non terminal                    primitive_type;
non terminal                    numeric_type;
non terminal                    reference_type;
non terminal                    class_or_interface_type;
non terminal                    array_type; // Type []
non terminal                    dims;



// statements (side effects)
non terminal                    block; // {block_statement[opt]}
non terminal                    block_statements;
non terminal                    block_statement;    // one of statement, class decl, local_var_decl
non terminal                    local_var_decl_statement; // local_var_decl + ;
non terminal                    local_var_decl;
non terminal                    var_declarators;
non terminal                    var_declarator;
non terminal                    var_declarator_id;
non terminal                    statement, statement_no_short_if, statement_without_trailing_substatement;
non terminal                    if_then_statement, if_then_else_statement, if_then_else_statement_no_short_if;
non terminal                    for_statement, for_statement_no_short_if;
non terminal                    for_init, for_update;
non terminal                    while_statement, while_statement_no_short_if;
non terminal                    return_statement;
non terminal                    empty_statement; //;

// evaluate the expression, if it has a value, than it's discard

non terminal                    expression_statement; // expression_statement = statement_expression + ;
non terminal                    statement_expression;
non terminal                    statement_expression_list; // seperate statement_expression by ','
non terminal                    assignment_expr; //
non terminal                    assignment;

// experssions (have values) and always use return value
non terminal                    expr;           // any statement that returns a value
non terminal                    cast_expr;
non terminal                    array_access;
non terminal                    array_creation_expr;
non terminal                    field_access;   //{...}.ID
non terminal                    class_instance_creation_expression;
non terminal                    primary, primary_no_new_array; // simplest kinds of expressions that evaluate first
non terminal                    literal;    // 123, "abc"
non terminal                    method_invocation;
non terminal                    unary_expr;   // -, +
non terminal                    unary_expr_not_plus_minus; // !, cast
non terminal                    post_fix_expr;
non terminal                    multiplicative_expr; // *, / %
non terminal                    additive_expr;  // +, -
non terminal                    relation_expr;  // >, <, = instanceof
non terminal                    equality_expr; // ==, !=
non terminal                    and_expr; // &
non terminal                    or_expr; // |
non terminal                    conditional_and_expr;
non terminal                    conditional_or_expr;
non terminal                    lhs;        // left hand side: ambiguous_name, field_access, array_access
non terminal                    dim_expr;

// parameters/arguments
non terminal                    parameter_list;
non terminal                    paramater;
non terminal                    argument_list;

// Name
non terminal                     name;





/** Precedence */

start with compilation_unit;

/** ============= GRAMMAR ============= */

// start
compilation_unit ::= | package_decl
                    | import_decls
                    | type_decls
                    | package_decl import_decls
                    | package_decl type_decls
                    | import_decls type_decls
                    | package_decl import_decls type_decls;


import_decls ::=  import_decl
                    | import_decls import_decl;

import_decl ::= single_type_import_decl
                    | type_import_ondemand_decl;

single_type_import_decl ::= IMPORT  name SEMICOLUMN;

type_import_ondemand_decl ::= IMPORT name DOT STAR SEMICOLUMN;

type_decls ::=  type_decls type_decl
                | type_decl;

type_decl ::= class_decl
            | interface_decl
            | SEMICOLUMN;

package_decl    ::=  PACKAGE name SEMICOLUMN;
//type_name   ::= ID
//                | package_or_type_name DOT ID;
//ambiguous_name   ::= ID
//                | ambiguous_name DOT ID;
//ambiguous_name   ::= ID
//                | ambiguous_name DOT ID;
name ::= ID
        | name DOT ID;




// Statements

block ::= LEFTCURLY block_statements RIGHTCURLY
        | LEFTCURLY RIGHTCURLY;

block_statements ::= block_statements block_statement
                    | block_statement;

block_statement ::= local_var_decl_statement
                    | statement;

local_var_decl_statement  ::= local_var_decl SEMICOLUMN;

local_var_decl  ::= type var_declarators;

var_declarators ::= var_declarator
                    | var_declarators COMMA var_declarator;

var_declarator ::= var_declarator_id
                    | var_declarator_id ASSIGN expr;

var_declarator_id ::= ID;

statement ::= statement_without_trailing_substatement
            | if_then_statement
            | if_then_else_statement
            | while_statement
            | for_statement;

statement_without_trailing_substatement ::= block   // single statement
                                            | empty_statement
                                            | expression_statement
                                            | return_statement;

statement_no_short_if ::= statement_without_trailing_substatement
                        | if_then_else_statement_no_short_if
                        | while_statement_no_short_if
                        | for_statement_no_short_if;

empty_statement ::= SEMICOLUMN;

expression_statement ::= statement_expression SEMICOLUMN;

statement_expression ::= assignment
                        | method_invocation
                        | class_instance_creation_expression;


// if statement

if_then_statement ::= IF LEFTPARN expr RIGHTPARN statement;

if_then_else_statement ::= IF LEFTPARN expr RIGHTPARN statement_no_short_if ELSE statement;

if_then_else_statement_no_short_if ::= IF LEFTPARN expr RIGHTPARN statement_no_short_if ELSE statement_no_short_if;

// while statement
while_statement ::= WHILE LEFTPARN expr RIGHTPARN statement;

while_statement_no_short_if ::= WHILE LEFTPARN expr RIGHTPARN statement_no_short_if;

// for statement
for_statement ::= FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement
                | FOR LEFTPARN for_init SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement
                | FOR LEFTPARN  SEMICOLUMN expr  SEMICOLUMN  RIGHTPARN statement
                | FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN for_update  RIGHTPARN statement
                | FOR LEFTPARN for_init SEMICOLUMN expr  SEMICOLUMN  RIGHTPARN statement
                | FOR LEFTPARN for_init SEMICOLUMN  SEMICOLUMN for_update RIGHTPARN statement
                | FOR LEFTPARN  SEMICOLUMN expr SEMICOLUMN for_update RIGHTPARN statement
                | FOR LEFTPARN for_init  SEMICOLUMN expr SEMICOLUMN for_update RIGHTPARN statement;

for_statement_no_short_if ::= FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN for_init SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN  SEMICOLUMN expr  SEMICOLUMN  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN for_update  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN for_init SEMICOLUMN expr  SEMICOLUMN  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN for_init SEMICOLUMN  SEMICOLUMN for_update RIGHTPARN statement_no_short_if
                | FOR LEFTPARN  SEMICOLUMN expr SEMICOLUMN for_update RIGHTPARN statement_no_short_if
                | FOR LEFTPARN for_init  SEMICOLUMN expr SEMICOLUMN for_update RIGHTPARN statement_no_short_if;

for_init ::=  type var_declarator
            | statement_expression;

for_update ::=  statement_expression;

statement_expression_list ::= statement_expression
                            | statement_expression_list COMMA statement_expression;

return_statement ::= RETURN expr SEMICOLUMN
                    | RETURN SEMICOLUMN;

// expressions
dim_expr ::= LEFTBRACKET expr RIGHTBARCKET;

primary ::= primary_no_new_array
            | array_creation_expr;

array_creation_expr ::= NEW primitive_type dim_expr
                    |  NEW class_or_interface_type dim_expr;



primary_no_new_array ::= literal
                         | THISLITERAL
                         | LEFTPARN expr RIGHTPARN
                         | class_instance_creation_expression
                         | field_access
                         | method_invocation
                         | array_access;


literal ::= INTGERLITERAL | TRUELITERAL | FALSELITERAL | CHARLITERAL | STRINGLITERAL | NULLLITERAL;

class_instance_creation_expression ::= NEW class_or_interface_type LEFTPARN argument_list RIGHTPARN
                                    |  NEW class_or_interface_type LEFTPARN RIGHTPARN;

argument_list ::=  expr
                | argument_list COMMA expr;


array_access ::= name LEFTBRACKET expr RIGHTBARCKET
                | primary_no_new_array LEFTBRACKET expr RIGHTBARCKET;

field_access ::= primary DOT ID;

method_invocation ::= name LEFTPARN argument_list RIGHTPARN
                    | name LEFTPARN  RIGHTPARN
                    | primary DOT ID LEFTPARN argument_list RIGHTPARN
                    | primary DOT ID LEFTPARN  RIGHTPARN;

post_fix_expr ::= primary
                  | name;

unary_expr  ::=  unary_expr_not_plus_minus
                | MINUS unary_expr;

unary_expr_not_plus_minus   ::= NOT unary_expr
                            |   cast_expr
                            | post_fix_expr;


cast_expr   ::= LEFTPARN primitive_type RIGHTPARN unary_expr
                | LEFTPARN expr RIGHTPARN unary_expr_not_plus_minus
                | LEFTPARN primitive_type dims RIGHTPARN unary_expr
                | LEFTPARN name dims RIGHTPARN unary_expr_not_plus_minus;

multiplicative_expr ::= unary_expr
                    |   multiplicative_expr STAR unary_expr
                    |   multiplicative_expr DIVIDES unary_expr
                    |   multiplicative_expr MOD unary_expr;

additive_expr ::= multiplicative_expr
                | additive_expr PLUS multiplicative_expr
                | additive_expr MINUS multiplicative_expr;

relation_expr ::= additive_expr
                | relation_expr LT additive_expr
                | relation_expr GT additive_expr
                | relation_expr LE additive_expr
                | relation_expr GE additive_expr
                | relation_expr INSTANCEOF reference_type;

equality_expr ::= relation_expr
                | equality_expr EQ relation_expr
                | equality_expr NE relation_expr;

and_expr ::= equality_expr
            | and_expr BITWISEAND equality_expr;

or_expr ::= and_expr
          | or_expr BITWISEOR and_expr;

conditional_and_expr ::= or_expr
                        | conditional_and_expr BINARYAND or_expr;

conditional_or_expr ::= conditional_and_expr
                        | conditional_or_expr BINARYOR conditional_and_expr;

assignment_expr ::= conditional_or_expr
                |   assignment;

assignment ::= lhs ASSIGN assignment_expr;

lhs ::= name
        | field_access
        | array_access;

expr ::= assignment_expr;


// type
dims ::= LEFTBRACKET RIGHTBARCKET;

type ::= primitive_type
        | reference_type;



primitive_type ::= numeric_type
                 | BOOL;

numeric_type ::= BYTE | SHORT | INT | CHAR;

reference_type ::= class_or_interface_type
                |  array_type;

class_or_interface_type ::= name;

class_type ::= class_or_interface_type;
interface_type ::= class_or_interface_type;

array_type ::= name dims
            |  primitive_type dims;


// class and interface
modifier ::= access_modifier | nonaccess_modifier | STATIC; // The doc also include private, final, strictfp

access_modifier ::= PUBLIC | PROTECTED;

nonaccess_modifier ::= ABSTRACT | NATIVE | FINAL;

modifiers ::= modifier | modifier modifiers;

// class
class_decl ::= CLASS ID class_body // identifier not found
               |
               modifiers CLASS ID class_body
               |
               modifiers CLASS ID Super class_body
               |
               modifiers CLASS ID interfaces class_body
               |
               modifiers CLASS ID Super interfaces class_body
               |
               CLASS ID Super class_body
               |
               CLASS ID Super interfaces class_body
               |
               CLASS ID interfaces class_body
               ;


interface_decl ::= INTERFACE ID interface_body
                   |
                   modifiers INTERFACE ID interface_body
                   |
                   INTERFACE ID extends_interfaces interface_body
                   |
                   modifiers INTERFACE ID extends_interfaces interface_body
                   ;

extends_interfaces ::= EXTENDS interface_type
                    |  extends_interfaces COMMA interface_type;

Super ::= EXTENDS class_type;

interfaces ::= IMPLEMENTS  interface_typelist;

interface_typelist ::= interface_type
                       |
                       interface_typelist COMMA interface_type
                       ;


class_body ::= LEFTCURLY class_body_decls RIGHTCURLY
               |
               LEFTCURLY RIGHTCURLY
               ;

class_body_decls ::= class_body_decl
                     |
                     class_body_decls class_body_decl
                     ;

class_body_decl ::= class_member_decl
                    |
                    constructor_decl
                    ;

class_member_decl ::= field_decl
                      |
                      method_decl
                      ;

constructor_decl ::= modifiers constructor_declarator constructor_body
                     |
                     constructor_declarator constructor_body
                     ;

field_decl ::= modifiers type var_declarators SEMICOLUMN
               |
               type var_declarators SEMICOLUMN
               ;

// adding in 8.4
// is this delcaration or declarator cuz abstract_method_decl asking for declarator
method_decl ::= method_header method_body; // missing method header and method body
method_header ::=  modifiers type method_declarator
                |  modifiers VOID method_declarator;

method_body ::= block
                | SEMICOLUMN;


method_declarator ::= ID LEFTPARN parameter_list RIGHTPARN
                    | ID LEFTPARN RIGHTPARN;

parameter_list ::=  paramater
                   | parameter_list COMMA paramater;

paramater ::= type var_declarator_id;


abstract_method_decl ::= modifiers type method_declarator;


interface_body ::= LEFTCURLY interface_member_decls RIGHTCURLY
                   |
                   LEFTCURLY RIGHTCURLY
                   ;

interface_member_decls ::= interface_member_decl
                           |
                           interface_member_decls interface_member_decl
                           ;
interface_member_decl ::= abstract_method_decl
                          ;


constructor_declarator ::= ID LEFTPARN parameter_list RIGHTPARN
                           |
                           ID LEFTPARN RIGHTPARN
                           ;
constructor_body ::= LEFTCURLY block_statements RIGHTCURLY
                     |
                     LEFTCURLY RIGHTCURLY;


