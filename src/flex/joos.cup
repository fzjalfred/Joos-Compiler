package lexer;
import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import ast.*;

parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    private List<ASTNode> list(){
            return new ArrayList<ASTNode>();
    }

    private List<ASTNode> list(ASTNode e1){
        return new ArrayList<ASTNode>(){{add(e1);}};
    }

    private List<ASTNode> list(ASTNode e1, ASTNode e2){
            return new ArrayList<ASTNode>(){{add(e1); add(e2);}};
    }

    private List<ASTNode> list(ASTNode e1, ASTNode e2, ASTNode e3){
        return new ArrayList<ASTNode>(){{add(e1); add(e2); add(e3);}};
    }
    private List<ASTNode> list(ASTNode e1, ASTNode e2, ASTNode e3, ASTNode e4){
        return new ArrayList<ASTNode>(){{add(e1); add(e2); add(e3); add(e4);}};
    }
    private List<ASTNode> list(ASTNode e1, ASTNode e2, ASTNode e3, ASTNode e4, ASTNode e5){
            return new ArrayList<ASTNode>(){{add(e1); add(e2); add(e3); add(e4); add(e5);}};
    }
    private List<ASTNode> addList(ASTNode e1, ASTNode e2){  // add e2 to e1's children, then return e1's children
        System.out.println("Begin current node is " + e1 + " add node " + e2);
        List<ASTNode> children = e1.children;
        children.add(e2);
        System.out.println("Done current node is " + e1 + " add node " + e2);
        return children;
    }
:};

/** Terminals */

terminal Token                  ID;

// Literals
terminal /* IntegerLiteral*/         INTGERLITERAL;
terminal /* CharLiteral */           CHARLITERAL;
terminal /* StringLiteral */         STRINGLITERAL;
terminal /* NullLiteral */          NULLLITERAL;
terminal /* ThisLiteral */            THISLITERAL;
terminal /* TrueLiteral */           TRUELITERAL;
terminal /* FalseLiteral */          FALSELITERAL;

// Type
terminal Token                  VOID, BOOL, INT, CHAR, BYTE, SHORT; // how to represent Array?

// OP
terminal Token                  PLUS, MINUS, DIVIDES, MOD, STAR; //Arithmatic OP
terminal Token                  BINARYAND, BINARYOR, NOT; // logic OP
terminal Token                  EQ, LT, LE, GT, GE, NE;  // Comp OP
terminal Token                  BITWISEAND, BITWISEOR; // bitwise OP
terminal Token                  ASSIGN, NEW, INSTANCEOF;    // other

// Symbols
terminal Token                  LEFTPARN, RIGHTPARN, LEFTBRACKET, RIGHTBARCKET,LEFTCURLY, RIGHTCURLY; // ()[]{}
terminal Token                  COMMA, DOT, SEMICOLUMN; // ,.

// Keywords
terminal Token                  FOR, WHILE, IF, ELSE, RETURN, NATIVE, PACKAGE, IMPORT; //program keywords
terminal Token                  CLASS, INTERFACE, ABSTRACT, PUBLIC, PROTECTED, STATIC, EXTENDS, IMPLEMENTS, SUPER, FINAL; // class keywords

/** Non-terminals **/
non terminal  CompilationUnit                   compilation_unit;   // the goal of joos
non terminal  TypeDecls                  type_decls;
non terminal  TypeDecl                  type_decl;
non terminal  ImportDecls                  import_decls;    // import java...
non terminal  ImportDecl                  import_decl;
non terminal  PackageDecl                  package_decl;   // package cs444.a1...
non terminal                    single_type_import_decl;
non terminal                    type_import_ondemand_decl;


// modifiers
nonterminal  Modifiers             modifiers;
nonterminal  Token                 modifier;



// class
non terminal    ClassDecl                    class_decl; // class modifiers class identifier Super interface classbody
non terminal    InterfaceDecl                    interface_decl;
non terminal    Super                    Super; // Super: extends ClassType;
non terminal    Interfaces                    interfaces; // : implements InterfaceTypeList
non terminal    ClassBody                    class_body;     // {class_body_decls}
non terminal    ClassBodyDecls                class_body_decls;
non terminal    ClassBodyDecl                class_body_decl;
non terminal    ClassMemberDecl                class_member_decl;
non terminal    ConstructorDecl                constructor_decl; // one of class_body_decl;
non terminal    FieldDecl                field_decl;
non terminal    MethodDecl                 method_decl; // ++ class_decl, interface_decl be one of class_member_decl;
non terminal    InterfaceBody                interface_body; // {interface_member_decl}
non terminal    InterfaceMemberDecls                interface_member_decls;
non terminal    InterfaceMemberDecl                interface_member_decl; //  one of abstract_method_decl, class_decl, interface_decl;
non terminal    AbstractMethodDecl                abstract_method_decl;   // optional abstract + methoddeclar
non terminal    ExtendsInterfaces                extends_interfaces;


// method
non terminal                    constructor_declarator;
non terminal                    constructor_body;
non terminal   MethodHeader                 method_header;
non terminal   MethodBody                 method_body;
non terminal                    method_declarator;

// type
non terminal    Type                 type;       // int, int[]
non terminal    ClassOrInterfaceType                    class_type;
non terminal    ClassOrInterfaceType                    interface_type;
non terminal    InterfaceTypeList                    interface_typelist;
non terminal    PrimitiveType                    primitive_type;
non terminal    NumericType                    numeric_type;
non terminal    ReferenceType                    reference_type;
non terminal    ClassOrInterfaceType                    class_or_interface_type;
non terminal    ArrayType                    array_type; // Type []
non terminal                    dims;



// statements (side effects)
non terminal                    block; // {block_statement[opt]}
non terminal                    block_statements;
non terminal                    block_statement;    // one of statement, class decl, local_var_decl
non terminal                    local_var_decl_statement; // local_var_decl + ;
non terminal                    local_var_decl;
non terminal                    var_declarators;
non terminal                    var_declarator;
non terminal                    var_declarator_id;
non terminal                    statement, statement_no_short_if, statement_without_trailing_substatement;
non terminal                    if_then_statement, if_then_else_statement, if_then_else_statement_no_short_if;
non terminal                    for_statement, for_statement_no_short_if;
non terminal                    for_init, for_update;
non terminal                    while_statement, while_statement_no_short_if;
non terminal                    return_statement;
non terminal                    empty_statement; //;

// evaluate the expression, if it has a value, than it's discard

non terminal                    expression_statement; // expression_statement = statement_expression + ;
non terminal                    statement_expression;
non terminal                    statement_expression_list; // seperate statement_expression by ','
non terminal                    assignment_expr; //
non terminal                    assignment;

// experssions (have values) and always use return value
non terminal                    expr;           // any statement that returns a value
non terminal                    cast_expr;
non terminal                    array_access;
non terminal                    array_creation_expr;
non terminal                    field_access;   //{...}.ID
non terminal                    class_instance_creation_expression;
non terminal                    primary, primary_no_new_array; // simplest kinds of expressions that evaluate first
non terminal                    literal;    // 123, "abc"
non terminal                    method_invocation;
non terminal                    unary_expr;   // -, +
non terminal                    unary_expr_not_plus_minus; // !, cast
non terminal                    post_fix_expr;
non terminal                    multiplicative_expr; // *, / %
non terminal                    additive_expr;  // +, -
non terminal                    relation_expr;  // >, <, = instanceof
non terminal                    equality_expr; // ==, !=
non terminal                    and_expr; // &
non terminal                    or_expr; // |
non terminal                    conditional_and_expr;
non terminal                    conditional_or_expr;
non terminal                    lhs;        // left hand side: ambiguous_name, field_access, array_access
non terminal                    dim_expr;

// parameters/arguments
non terminal                    parameter_list;
non terminal                    paramater;
non terminal                    argument_list;

// Name
non terminal      Name               name;





/** Precedence */

start with compilation_unit;

/** ============= GRAMMAR ============= */

// start
compilation_unit ::= | package_decl:e1 {:RESULT = new CompilationUnit(list(e1, null, null), "");  :}
                    | import_decls:e2  {:RESULT = new CompilationUnit(list(null, e2, null), "");  :}
                    | type_decls:e3 {:RESULT = new CompilationUnit(list(null, null, e3), "");  :}
                    | package_decl:e1 import_decls:e2 {:RESULT = new CompilationUnit(list(e1, e2, null), "");  :}
                    | package_decl:e1 type_decls:e3 {:RESULT =  new CompilationUnit(list(e1, null, e3), "");  :}
                    | import_decls:e2 type_decls:e3 {:RESULT = new CompilationUnit(list(null, e2, e3), "");  :}
                    | package_decl:e1 import_decls:e2 type_decls:e3 {:RESULT = new CompilationUnit(list(e1, e2, e3), "");  :};


import_decls ::=  import_decl:e1 {:RESULT = new ImportDecls(list(e1), "");  :}
                    | import_decls:e1 import_decl:e2 {:RESULT = new ImportDecls(addList(e1, e2), "");:};

import_decl ::= single_type_import_decl {:RESULT = new ImportDecl(list(), ""); :}
                    | type_import_ondemand_decl {:RESULT = new ImportDecl(list(), ""); :};

single_type_import_decl ::= IMPORT  name SEMICOLUMN;

type_import_ondemand_decl ::= IMPORT name DOT STAR SEMICOLUMN;

type_decls ::=  type_decls:e1 type_decl:e2 {:RESULT = new TypeDecls(addList(e1, e2), "");:}
                | type_decl: e1 {:RESULT = new TypeDecls(list(e1), "");:};

type_decl ::= class_decl:e1 {:RESULT = new TypeDecl(list(e1), ""); :}
            | interface_decl:e1 {:RESULT = new TypeDecl(list(e1), ""); :}
            | SEMICOLUMN {:RESULT = new TypeDecl(list(), ""); :};

package_decl    ::=  PACKAGE name:e1 SEMICOLUMN {:RESULT = new PackageDecl(list(e1), ""); :};

name ::= ID:e1 {:RESULT = new Name(list(e1), "");:}
        | name:e1 DOT ID:e2 {:RESULT = new Name(addList(e1, e2), "");:};




// Statements

block ::= LEFTCURLY block_statements RIGHTCURLY
        | LEFTCURLY RIGHTCURLY;

block_statements ::= block_statements block_statement
                    | block_statement;

block_statement ::= local_var_decl_statement
                    | statement;

local_var_decl_statement  ::= local_var_decl SEMICOLUMN;

local_var_decl  ::= type var_declarators;

var_declarators ::= var_declarator
                    | var_declarators COMMA var_declarator;

var_declarator ::= var_declarator_id
                    | var_declarator_id ASSIGN expr;

var_declarator_id ::= ID;

statement ::= statement_without_trailing_substatement
            | if_then_statement
            | if_then_else_statement
            | while_statement
            | for_statement;

statement_without_trailing_substatement ::= block   // single statement
                                            | empty_statement
                                            | expression_statement
                                            | return_statement;

statement_no_short_if ::= statement_without_trailing_substatement
                        | if_then_else_statement_no_short_if
                        | while_statement_no_short_if
                        | for_statement_no_short_if;

empty_statement ::= SEMICOLUMN;

expression_statement ::= statement_expression SEMICOLUMN;

statement_expression ::= assignment
                        | method_invocation
                        | class_instance_creation_expression;


// if statement

if_then_statement ::= IF LEFTPARN expr RIGHTPARN statement;

if_then_else_statement ::= IF LEFTPARN expr RIGHTPARN statement_no_short_if ELSE statement;

if_then_else_statement_no_short_if ::= IF LEFTPARN expr RIGHTPARN statement_no_short_if ELSE statement_no_short_if;

// while statement
while_statement ::= WHILE LEFTPARN expr RIGHTPARN statement;

while_statement_no_short_if ::= WHILE LEFTPARN expr RIGHTPARN statement_no_short_if;

// for statement
for_statement ::= FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement
                | FOR LEFTPARN for_init SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement
                | FOR LEFTPARN  SEMICOLUMN expr  SEMICOLUMN  RIGHTPARN statement
                | FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN for_update  RIGHTPARN statement
                | FOR LEFTPARN for_init SEMICOLUMN expr  SEMICOLUMN  RIGHTPARN statement
                | FOR LEFTPARN for_init SEMICOLUMN  SEMICOLUMN for_update RIGHTPARN statement
                | FOR LEFTPARN  SEMICOLUMN expr SEMICOLUMN for_update RIGHTPARN statement
                | FOR LEFTPARN for_init  SEMICOLUMN expr SEMICOLUMN for_update RIGHTPARN statement;

for_statement_no_short_if ::= FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN for_init SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN  SEMICOLUMN expr  SEMICOLUMN  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN for_update  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN for_init SEMICOLUMN expr  SEMICOLUMN  RIGHTPARN statement_no_short_if
                | FOR LEFTPARN for_init SEMICOLUMN  SEMICOLUMN for_update RIGHTPARN statement_no_short_if
                | FOR LEFTPARN  SEMICOLUMN expr SEMICOLUMN for_update RIGHTPARN statement_no_short_if
                | FOR LEFTPARN for_init  SEMICOLUMN expr SEMICOLUMN for_update RIGHTPARN statement_no_short_if;

for_init ::=  type var_declarator
            | statement_expression;

for_update ::=  statement_expression;

statement_expression_list ::= statement_expression
                            | statement_expression_list COMMA statement_expression;

return_statement ::= RETURN expr SEMICOLUMN
                    | RETURN SEMICOLUMN;

// expressions
dim_expr ::= LEFTBRACKET expr RIGHTBARCKET;

primary ::= primary_no_new_array
            | array_creation_expr;

array_creation_expr ::= NEW primitive_type dim_expr
                    |  NEW class_or_interface_type dim_expr;



primary_no_new_array ::= literal
                         | THISLITERAL
                         | LEFTPARN expr RIGHTPARN
                         | class_instance_creation_expression
                         | field_access
                         | method_invocation
                         | array_access;


literal ::= INTGERLITERAL | TRUELITERAL | FALSELITERAL | CHARLITERAL | STRINGLITERAL | NULLLITERAL;

class_instance_creation_expression ::= NEW class_or_interface_type LEFTPARN argument_list RIGHTPARN
                                    |  NEW class_or_interface_type LEFTPARN RIGHTPARN;

argument_list ::=  expr
                | argument_list COMMA expr;


array_access ::= name LEFTBRACKET expr RIGHTBARCKET
                | primary_no_new_array LEFTBRACKET expr RIGHTBARCKET;

field_access ::= primary DOT ID;

method_invocation ::= name LEFTPARN argument_list RIGHTPARN
                    | name LEFTPARN  RIGHTPARN
                    | primary DOT ID LEFTPARN argument_list RIGHTPARN
                    | primary DOT ID LEFTPARN  RIGHTPARN;

post_fix_expr ::= primary
                  | name;

unary_expr  ::=  unary_expr_not_plus_minus
                | MINUS unary_expr;

unary_expr_not_plus_minus   ::= NOT unary_expr
                            |   cast_expr
                            | post_fix_expr;


cast_expr   ::= LEFTPARN primitive_type RIGHTPARN unary_expr
                | LEFTPARN expr RIGHTPARN unary_expr_not_plus_minus
                | LEFTPARN primitive_type dims RIGHTPARN unary_expr
                | LEFTPARN name dims RIGHTPARN unary_expr_not_plus_minus;

multiplicative_expr ::= unary_expr
                    |   multiplicative_expr STAR unary_expr
                    |   multiplicative_expr DIVIDES unary_expr
                    |   multiplicative_expr MOD unary_expr;

additive_expr ::= multiplicative_expr
                | additive_expr PLUS multiplicative_expr
                | additive_expr MINUS multiplicative_expr;

relation_expr ::= additive_expr
                | relation_expr LT additive_expr
                | relation_expr GT additive_expr
                | relation_expr LE additive_expr
                | relation_expr GE additive_expr
                | relation_expr INSTANCEOF reference_type;

equality_expr ::= relation_expr
                | equality_expr EQ relation_expr
                | equality_expr NE relation_expr;

and_expr ::= equality_expr
            | and_expr BITWISEAND equality_expr;

or_expr ::= and_expr
          | or_expr BITWISEOR and_expr;

conditional_and_expr ::= or_expr
                        | conditional_and_expr BINARYAND or_expr;

conditional_or_expr ::= conditional_and_expr
                        | conditional_or_expr BINARYOR conditional_and_expr;

assignment_expr ::= conditional_or_expr
                |   assignment;

assignment ::= lhs ASSIGN assignment_expr;

lhs ::= name
        | field_access
        | array_access;

expr ::= assignment_expr;


// type
dims ::= LEFTBRACKET RIGHTBARCKET;

type ::= primitive_type:e {:RESULT = e;:}
        | reference_type:e {:RESULT = e;:};



primitive_type ::= numeric_type:e {:RESULT = e;:}
                 | BOOL:e {:RESULT = new PrimitiveType(list(), e.value);:};

numeric_type ::= BYTE:e {:RESULT = new NumericType(list(), e.value);:}
                | SHORT:e {:RESULT = new NumericType(list(), e.value);:}
                | INT:e {:RESULT = new NumericType(list(), e.value);:}
                | CHAR:e {:RESULT = new NumericType(list(), e.value);:};

reference_type ::= class_or_interface_type:e {:RESULT = e;:}
                |  array_type:e {:RESULT = e;:};

class_or_interface_type ::= name:e {:RESULT = new ClassOrInterfaceType(list(e), "");:};

class_type ::= class_or_interface_type;
interface_type ::= class_or_interface_type;

array_type ::= name:e dims  {:RESULT = new ArrayType(list(new ClassOrInterfaceType(list(e), "")), "");:}
            |  primitive_type:e dims {:RESULT = new ArrayType(list(e), "");:};


// class and interface
modifier ::= PUBLIC:e {:RESULT = e;:}
        | PROTECTED:e {:RESULT = e;:}
        | ABSTRACT:e {:RESULT = e;:}
        | NATIVE:e {:RESULT = e;:}
        | FINAL:e {:RESULT = e;:}
        | STATIC:e {:RESULT = e;:};

modifiers ::= modifier:e {:RESULT = new Modifiers(list(e), "");:}
           | modifiers:e1 modifier:e2 {:RESULT = new Modifiers(addList(e1,e2), "");:};

// class
class_decl ::= CLASS ID:e2 class_body:e5 {:RESULT = new ClassDecl(list(null, e2, null, null, e5), "");:}// identifier not found
               |
               modifiers:e1 CLASS ID:e2 class_body:e5 {:RESULT = new ClassDecl(list(e1, e2, null, null, e5), "");:}
               |
               modifiers:e1 CLASS ID:e2 Super:e3 class_body:e5 {:RESULT = new ClassDecl(list(e1, e2, e3, null, e5), "");:}
               |
               modifiers:e1 CLASS ID:e2 interfaces:e4 class_body:e5 {:RESULT = new ClassDecl(list(e1, e2, null, e4, e5), "");:}
               |
               modifiers:e1 CLASS ID:e2 Super:e3 interfaces:e4 class_body:e5 {:RESULT = new ClassDecl(list(e1, e2, e3, e4, e5), "");:}
               |
               CLASS ID:e2 Super:e3 class_body:e5 {:RESULT = new ClassDecl(list(null, e2, e3, null, e5), "");:}
               |
               CLASS ID:e2 Super:e3 interfaces:e4 class_body:e5 {:RESULT = new ClassDecl(list(null, e2, e3, e4, e5), "");:}
               |
               CLASS ID:e2 interfaces:e4 class_body:e5 {:RESULT = new ClassDecl(list(null, e2, null, e4, e5), "");:}
               ;


interface_decl ::= INTERFACE ID:e2 interface_body:e4 {:RESULT = new InterfaceDecl(list(null, e2, null, e4), "");:}
                   |
                   modifiers:e1 INTERFACE ID:e2 interface_body:e4 {:RESULT = new InterfaceDecl(list(e1, e2, null, e4), "");:}
                   |
                   INTERFACE ID:e2 extends_interfaces:e3 interface_body:e4 {:RESULT = new InterfaceDecl(list(null, e2, e3, e4), "");:}
                   |
                   modifiers:e1 INTERFACE ID:e2 extends_interfaces:e3 interface_body:e4 {:RESULT = new InterfaceDecl(list(e1, e2, e3, e4), "");:}
                   ;

extends_interfaces ::= EXTENDS interface_type:e {:RESULT = new ExtendsInterfaces(list(e), "");:}
                    |  extends_interfaces:e1 COMMA interface_type:e2 {:RESULT = new ExtendsInterfaces(addList(e1,e2), "");:};

Super ::= EXTENDS class_type:e {:RESULT = new Super(list(e), "");:};

interfaces ::= IMPLEMENTS  interface_typelist:e {:RESULT = new Interfaces(list(e), "");:};

interface_typelist ::= interface_type:e {:RESULT = new InterfaceTypeList(list(e), "");:}
                       |
                       interface_typelist:e1 COMMA interface_type:e2 {:RESULT = new InterfaceTypeList(addList(e1,e2), "");:}
                       ;


class_body ::= LEFTCURLY class_body_decls:e RIGHTCURLY {:RESULT = new ClassBody(list(e), "");:}
               |
               LEFTCURLY RIGHTCURLY {:RESULT = new ClassBody(list(null), "");:}
               ;

class_body_decls ::= class_body_decl:e {:RESULT = new ClassBodyDecls(list(e), "");:}
                     |
                     class_body_decls:e1 class_body_decl:e2 {:RESULT = new ClassBodyDecls(addList(e1,e2), "");:}
                     ;

class_body_decl ::= class_member_decl:e {:RESULT = new ClassBodyDecl(list(e), "");:}
                    |
                    constructor_decl:e {:RESULT = new ClassBodyDecl(list(e), "");:}
                    ;

class_member_decl ::= field_decl:e {:RESULT = e;:}
                      |
                      method_decl:e {:RESULT = e;:}
                      ;

constructor_decl ::= modifiers constructor_declarator constructor_body
                     |
                     constructor_declarator constructor_body
                     ;

field_decl ::= modifiers:e1 type:e2 var_declarators:e3 SEMICOLUMN {:RESULT = new FieldDecl(list(e1,e2,null), "");:} //TODO: replace null with e3
               |
               type:e1 var_declarators:e2 SEMICOLUMN {:RESULT = new FieldDecl(list(e1,null), "");:}
               ;

// adding in 8.4
// is this delcaration or declarator cuz abstract_method_decl asking for declarator
method_decl ::= method_header:e1 method_body:e2 {:RESULT = new MethodDecl(list(e1,e2), "");:}; //TODO: replace null with e3
method_header ::=  modifiers:e1 type:e2 method_declarator:e3 {:RESULT = new MethodHeader(list(e1,e2, null), "");:}
                |  modifiers:e1 VOID:e2 method_declarator:e3 {:RESULT = new MethodHeader(list(e1,e2, null), "");:};

method_body ::= block:e  {:RESULT = new MethodBody(list(null), "");:} //TODO: replace null with e
                | SEMICOLUMN {:RESULT = new MethodBody(list(null), "");:};


method_declarator ::= ID LEFTPARN parameter_list RIGHTPARN
                    | ID LEFTPARN RIGHTPARN;

parameter_list ::=  paramater
                   | parameter_list COMMA paramater;

paramater ::= type var_declarator_id;


abstract_method_decl ::= modifiers type method_declarator;


interface_body ::= LEFTCURLY interface_member_decls:e RIGHTCURLY {:RESULT = new InterfaceBody(list(e), "");:}
                   |
                   LEFTCURLY RIGHTCURLY {:RESULT = new InterfaceBody(list(), "");:}
                   ;

interface_member_decls ::= interface_member_decl:e {:RESULT = new InterfaceMemberDecls(list(e), "");:}
                           |
                           interface_member_decls:e1 interface_member_decl:e2 {:RESULT = new InterfaceMemberDecls(addList(e1,e2), "");:}
                           ;
interface_member_decl ::= abstract_method_decl  {:RESULT = new InterfaceMemberDecl(list(), "");:}
                          ;


constructor_declarator ::= ID LEFTPARN parameter_list RIGHTPARN
                           |
                           ID LEFTPARN RIGHTPARN
                           ;
constructor_body ::= LEFTCURLY block_statements RIGHTCURLY
                     |
                     LEFTCURLY RIGHTCURLY;


