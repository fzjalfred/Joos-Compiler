package lexer;
import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import ast.*;

parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    private List<ASTNode> list(){
            return new ArrayList<ASTNode>();
    }

    private List<ASTNode> list(ASTNode e1){
        return new ArrayList<ASTNode>(){{add(e1);}};
    }

    private List<ASTNode> list(ASTNode e1, ASTNode e2){
            return new ArrayList<ASTNode>(){{add(e1); add(e2);}};
    }

    private List<ASTNode> list(ASTNode e1, ASTNode e2, ASTNode e3){
        return new ArrayList<ASTNode>(){{add(e1); add(e2); add(e3);}};
    }
    private List<ASTNode> list(ASTNode e1, ASTNode e2, ASTNode e3, ASTNode e4){
        return new ArrayList<ASTNode>(){{add(e1); add(e2); add(e3); add(e4);}};
    }
    private List<ASTNode> list(ASTNode e1, ASTNode e2, ASTNode e3, ASTNode e4, ASTNode e5){
            return new ArrayList<ASTNode>(){{add(e1); add(e2); add(e3); add(e4); add(e5);}};
    }
    private List<ASTNode> addList(ASTNode e1, ASTNode e2){  // add e2 to e1's children, then return e1's children
        System.out.println("Begin current node is " + e1 + " add node " + e2);
        List<ASTNode> children = e1.children;
        children.add(e2);
        System.out.println("Done current node is " + e1 + " add node " + e2);
        return children;
    }

    private boolean NotClassModifier(Modifiers modifiers){
            List <String> classModifierList = new ArrayList<String>() {{add("public"); add("protected"); add("abstract");
            add("static"); add("final");}};

            boolean isAbstract = false;

            List<ASTNode> children = modifiers.children;
            for (ASTNode node : children) {
                if (!classModifierList.contains(node.value)){
                    return true;
                }
                if (node.value == "abstract"){
                    isAbstract = true;
                }
            }
            // check for abstract class
            if (isAbstract){
                for (ASTNode node : children){
                    if (node.value == "final"){
                        return true;
                    }
                }
            }
            return false;
    }

    private boolean NotInterfaceModifier(Modifiers modifiers) {
        List <String> interfaceModifierList = new ArrayList<String>() {{add("public"); add("protected"); add("abstract");
            add("static"); add("final");}};

        List<ASTNode> children = modifiers.children;
        for (ASTNode node : children) {
            if (!interfaceModifierList.contains(node.value)){
                return true;
            }
        }
        return false;
    }

    private boolean NotConstructorModifier(Modifiers modifiers) {
        List <String> constructorModifierList = new ArrayList<String>() {{add("public"); add("protected");}};

        List<ASTNode> children = modifiers.children;
        for (ASTNode node : children) {
            if (!constructorModifierList.contains(node.value)){
                return true;
            }
        }
        return false;
    }

     private boolean NotFieldModifier(Modifiers modifiers) {
         List <String> fieldModifierList = new ArrayList<String>() {{add("public"); add("protected");add("static");}};

         List<ASTNode> children = modifiers.children;
         for (ASTNode node : children) {
             if (!fieldModifierList.contains(node.value)){
                 return true;
             }
         }
         return false;
     }

     private boolean NotMethodModifier(Modifiers modifiers) {
         List <String> methodModifierList = new ArrayList<String>() {{add("public"); add("protected");add("abstract");
         add("static"); add("final"); add("native");}};

         boolean isAbstract = false;
         boolean isStatic = false;
         List<ASTNode> children = modifiers.children;
         for (ASTNode node : children) {
             if (!methodModifierList.contains(node.value)){
                 return true;
             }
             if (node.value == "abstract"){
                isAbstract = true;
                }

             if (node.value == "static"){
                isStatic = true;
             }
         }

         if (isAbstract || isStatic){
            for (ASTNode node : children){
                 if (isAbstract && (node.value == "final" || node.value == "static")){
                    return true;
                 }
                 if (isStatic && node.value == "final"){
                     return true;
                 }
            }
         }
         return false;
     }

     private boolean IncorrectClassName(Token token){
        char []  name = token.value.toCharArray();
        int length = name.length;
        if (length == 0){
            return true;
            }

        if (name[0] < 65 || name[0] > 90){
            return true;
            }

        for (int i = 1; i < length; i++){
            if (!((65 <= name[i] && name[i] <= 90) || (97 <= name[i] && name[i] <= 122))){
                return true;
                }
            }
        return false;
        }


     private boolean NotAbstractMethodModifier(Modifiers modifiers) {
         List <String> abstractMethodModifierList = new ArrayList<String>() {{add("public"); add("abstract");}};


         List<ASTNode> children = modifiers.children;
         for (ASTNode node : children) {
             if (!abstractMethodModifierList.contains(node.value)){
                 return true;
             }

         }

         return false;
     }

private boolean IncorrectCastExpr(ASTNode node){
             if (node instanceof PostFixExpr){
                 // System.out.println(node);
                 List<ASTNode> postFixChildren = node.children;
                 if (postFixChildren.size() != 1) {
                     return true;
                 }

                 if (postFixChildren.get(0) instanceof Name) {
                    List<ASTNode> nameChilren = postFixChildren.get(0).children;
                    if (nameChilren.size() == 1) {
                        return false;
                    }
                 }
             }

             return true;
    }

     private boolean IsOctalNumber(char [] chars) {

            if (48 <= chars[0] && chars[0] <= 50 && 48 <= chars[1] && chars[1] <= 57 && 48 <= chars[2] && chars[2] <= 57) {
                return true;
            }
            if (chars[0] == 51 && 48 <= chars[1] && chars[1] <= 54 && 48 <= chars[2] && chars[2] <= 57) {
                return true;
            }
            if (chars[0] == 51 && chars[1] <= 55 && 48 <= chars[2] && chars[2] <= 55) {
                return true;
            }
            return false;
     }


     private boolean NotCorrectEscapeChar(Token token){
        char [] chars = token.value.toCharArray();
//        ArrayList <char> charLiteralList = new ArrayList<char>() {{add('\b'); add('\t'); add('\n'); add('\f'); add('\r');
//        add('\"'); add('\''); add('\\');}};

        int size = chars.length;
        if (size == 3 && 0 <= chars[1] && chars[1] <= 127) {

            return false;
        }
        if (chars[1] == '\\') {
            if (size == 4 && (chars[2] == 'b' || chars[2] == 't' || chars[2] == 'r' ||chars[2] == 'n' || chars[2] == 'f' || chars[2] == '\"' ||
            chars[2] == '\'' || chars[2] == '\\')) {
                //System.out.println(chars[1]);
                //System.out.println(chars[2]);
                return false;
            }
            if (size == 6 && 48 <= chars[2] && chars[2] <= 51 && 48 <= chars[3] && chars[3] <= 55 && 48 <= chars[4] && chars[4] <= 55) {
                //System.out.println(size);
                return false;
                }

            // unicode cases not needed

        }
        return true;
        }
        private boolean NotCorrectEscapeString(Token token) {
            char [] chars = token.value.toCharArray();
            int size = chars.length;
            boolean checkNext = false;
            for (int i = 1; i < size-1; i++) {
            //System.out.println(chars[i]);
                if (!checkNext && chars[i] == '\\') {
                    checkNext = true;
                } else if (checkNext) {
                    if (chars[i] == 'b' || chars[i] == 't' || chars[i] == 'r' || chars[i] == 'n' || chars[i] == 'f' || chars[i] == '\"' || chars[i] == '\'' ||
                    chars[i] == '\\') {
                        checkNext = false;
                        continue;
                    }
                    if (i + 2 < size - 1){
                        boolean result = IsOctalNumber(Arrays.copyOfRange(chars, i, i+3));
                        if (result == true){
                            checkNext = false;
                            continue;
                        }
                    }
                    return true;
                }

            }
            if (checkNext) {
                return true;
            }
            return false;
        }

    private boolean IsInvalidID(Token token){
        String value = token.value;


        if (value.equals("abstract") || value.equals("private") || value.equals("assert") || value.equals("boolean") || value.equals("break") ||
         value.equals("byte") || value.equals("case") || value.equals("catch") || value.equals("char") || value.equals("class") || value.equals("const") ||
         value.equals("continue") || value.equals("default") || value.equals("do") || value.equals("double") || value.equals("else") || value.equals("enum") ||
         value.equals("extends") || value.equals("final") || value.equals("finally") || value.equals("float") || value.equals("for") || value.equals("goto") ||
         value.equals("if") || value.equals("implements") || value.equals("import") || value.equals("interface") || value.equals("instanceof") ||
         value.equals("int") || value.equals("long") || value.equals("native") || value.equals("protected") || value.equals("public") || value.equals("static") ||
         value.equals("strictfp") || value.equals("super") || value.equals("short") || value.equals("return") || value.equals("synchronized") || value.equals("throw") ||
         value.equals("this") || value.equals("transient") || value.equals("try") || value.equals("throws") || value.equals("Package") || value.equals("private") ||
         value.equals("switch") || value.equals("void") || value.equals("volatile") || value.equals("Date") || value.equals("while")) {
         return true;
         }

         return false;
    }

    private boolean InvalidIntRange(Token token){
        char [] value = token.value.toCharArray();

        if (value.length > 10){
            return true;
        }

        char [] chars = new char[] {'2','1','4','7','4','8','3','6','4','8' };
        if (value.length == 10 ) {
            for (int i = 0; i < 10; i++) {
                if (value[i] < chars[i]) {
                    break;
                } else if (value[i] > chars[i]) {
                    return true;
                }

            }
        }
        return false;
    }

    // check only one public class
    public String publicFileName = "";
    public List<String> classList = new ArrayList<String>();

    private boolean ifContainModifier(ASTNode modifiers, String name){
        if (modifiers == null) return false;
        for (ASTNode n : modifiers.children){
            if (n.value == name) return true;
        }
        return false;
    }
    private void checkModifiers(ASTNode modifiers) throws Exception {
        if (!(ifContainModifier(modifiers, "public") || ifContainModifier(modifiers, "protected"))) {
            throw new Exception("Contains no access modifiers");
        }
        int length = modifiers.children.size();
        for (int i = 0; i < length; i++) {
            for (int j = i+1; j < length; j++) {
                if (modifiers.children.get(i).value == modifiers.children.get(j).value) {
                    throw new Exception("Duplicated Modifier name");
                }
            }
        }
    }
    // only one and only one public class can exist; public class name should match filename.
    private void checkInvalidFileName(ASTNode modifiers, Token id) throws Exception{
        classList.add(id.value);
        if (ifContainModifier(modifiers, "public")){
            if (publicFileName == ""){
                publicFileName = id.value;
            }   else {
                throw new Exception("public name has already been initialized");
            }
        }   else {
            if (publicFileName != ""){
                throw new Exception("public name has already been initialized");
            }
        }
    }

    private void checkInvalidMethodName(ASTNode name) throws Exception {
        String methodName = name.children.get(0).value;
        //System.out.println(methodName);
        if (methodName.equals("super") || methodName.equals("this")) {
            throw new Exception("Invalid method name super or this");
        }
    }

    private void setNumberBound(ASTNode node, long num) throws Exception{
        if (node instanceof NumericLiteral ){
            NumericLiteral literal = (NumericLiteral)node;
            literal.setBound(num);
        }
    }

    private void checkInvalidMethodBody(ASTNode header, ASTNode body) throws Exception {
        // check if it is an abstract method
        ASTNode modifiers = header.children.get(0);
        boolean isAbstract = false;
        boolean isNative = false;
        for (ASTNode modifier : modifiers.children) {
            if (modifier.value == "abstract") {
                isAbstract = true;
            }
            if (modifier.value == "native") {
                isNative = true;
            }
        }
        if (isAbstract || isNative) {
            if (body.children.get(0) != null) {
                throw new Exception("Abstract or native method should have empty body");
            }
        } else {
            if (body.children.get(0) == null) {
                throw new Exception("Non-abstract and non-native method must have a body");
            }
        }
    }

    private void checkConstructorDecl(ASTNode classBodyDecls) throws Exception {
        List <ASTNode> children = classBodyDecls.children;
        boolean hasConstructor = false;
        for (ASTNode node : children){
            if (node instanceof ConstructorDecl){
                hasConstructor = true;
            }
        }

        if (!hasConstructor){
            throw new Exception("A class must have a constructor");
        }
    }

:};

/** Terminals */

terminal Token                  ID;

// Literals
terminal    Token/* IntegerLiteral*/         INTGERLITERAL;
terminal    Token/* CharLiteral */           CHARLITERAL;
terminal    Token/* StringLiteral */         STRINGLITERAL;
terminal    Token/* NullLiteral */          NULLLITERAL;
terminal    Token/* ThisLiteral */            THISLITERAL;
terminal    Token/* TrueLiteral */           TRUELITERAL;
terminal    Token/* FalseLiteral */          FALSELITERAL;

// Type
terminal Token                  VOID, BOOL, INT, CHAR, BYTE, SHORT; // how to represent Array?
//// reserved keywords
//terminal                            PRIVATE, ASSERT, BREAK, CASE, CATCH, CONTINUE,
//                                    DEFAULT, CONST, DO, DOUBLE, ENUM, FINALLY, LONG, STRICTFP, SYNCHONIZED, THROW,
//                                    TRANSIENT, TRY, THROWS, SWITCH, VOLATILE, DATE;
// OP
terminal Token                  PLUS, MINUS, DIVIDES, MOD, STAR; //Arithmatic OP
terminal Token                  BINARYAND, BINARYOR, NOT; // logic OP
terminal Token                  EQ, LT, LE, GT, GE, NE;  // Comp OP
terminal Token                  BITWISEAND, BITWISEOR; // bitwise OP
terminal Token                  ASSIGN, NEW, INSTANCEOF;    // other

// Symbols
terminal Token                  LEFTPARN, RIGHTPARN, LEFTBRACKET, RIGHTBARCKET,LEFTCURLY, RIGHTCURLY; // ()[]{}
terminal Token                  COMMA, DOT, SEMICOLUMN; // ,.

// Keywords
terminal Token                  FOR, WHILE, IF, ELSE, RETURN, NATIVE, PACKAGE, IMPORT; //program keywords
terminal Token                  CLASS, INTERFACE, ABSTRACT, PUBLIC, PROTECTED, STATIC, EXTENDS, IMPLEMENTS, SUPER, FINAL; // class keywords

// Invalid Terminals


/** Non-terminals **/
non terminal  CompilationUnit                   compilation_unit;   // the goal of joos
non terminal  TypeDecls                  type_decls;
non terminal  TypeDecl                  type_decl;
non terminal  ImportDecls                  import_decls;    // import java...
non terminal  ImportDecl                  import_decl;
non terminal  PackageDecl                  package_decl;   // package cs444.a1...
non terminal  SingleTypeImportDecl                  single_type_import_decl;
non terminal  TypeImportOndemandDecl                  type_import_ondemand_decl;


// modifiers
nonterminal  Modifiers             modifiers;
nonterminal  Token                 modifier;
nonterminal NumericLiteral         numeric_literal;



// class
non terminal    ClassDecl                    class_decl; // class modifiers class identifier Super interface classbody
non terminal    InterfaceDecl                    interface_decl;
non terminal    Super                    Super; // Super: extends ClassType;
non terminal    Interfaces                    interfaces; // : implements InterfaceTypeList
non terminal    ClassBody                    class_body;     // {class_body_decls}
non terminal    ClassBodyDecls                class_body_decls;
non terminal    ClassBodyDecl                class_body_decl;
non terminal    ClassMemberDecl                class_member_decl;
non terminal    ConstructorDecl                constructor_decl; // one of class_body_decl;
non terminal    FieldDecl                field_decl;
non terminal    MethodDecl                 method_decl; // ++ class_decl, interface_decl be one of class_member_decl;
non terminal    InterfaceBody                interface_body; // {interface_member_decl}
non terminal    InterfaceMemberDecls                interface_member_decls;
non terminal    InterfaceMemberDecl                interface_member_decl; //  one of abstract_method_decl, class_decl, interface_decl;
non terminal    AbstractMethodDecl                abstract_method_decl;   // optional abstract + methoddeclar
non terminal    ExtendsInterfaces                extends_interfaces;


// method
non terminal   ConstructorDeclarator                 constructor_declarator;
non terminal   ConstructorBody                 constructor_body;
non terminal   MethodHeader                 method_header;
non terminal   MethodBody                 method_body;
non terminal   MethodDeclarator                 method_declarator;

// type
non terminal    Type                 type;       // int, int[]
non terminal    ClassOrInterfaceType                    class_type;
non terminal    ClassOrInterfaceType                    interface_type;
non terminal    InterfaceTypeList                    interface_typelist;
non terminal    PrimitiveType                    primitive_type;
non terminal    NumericType                    numeric_type;
non terminal    ReferenceType                    reference_type;
non terminal    ClassOrInterfaceType                    class_or_interface_type;
non terminal    ArrayType                    array_type; // Type []
non terminal    Dims                dims;



// statements (side effects)
non terminal    Block                block; // {block_statement[opt]}
non terminal    BlockStmts                block_statements;
non terminal    BlockStmt                block_statement;    // one of statement, class decl, local_var_decl
non terminal    LocalVarDeclStmt                local_var_decl_statement; // local_var_decl + ;
non terminal    LocalVarDecl                local_var_decl;
non terminal    VarDeclarators                var_declarators;
non terminal    VarDeclarator                var_declarator;
non terminal    VarDeclaratorID                var_declarator_id;
non terminal    Stmt                statement;
non terminal    StmtNotIf                statement_no_short_if;
non terminal    StmtWithoutSubstmt                statement_without_trailing_substatement;
non terminal    IfThenStmt                if_then_statement;
non terminal    IfThenElseStmt                if_then_else_statement;
non terminal    IfThenElseStmtNotIf                if_then_else_statement_no_short_if;
non terminal    ForStmt                for_statement;
non terminal    ForStmtNotIf                for_statement_no_short_if;
non terminal    ForInit                for_init;
non terminal    ForUpdate                for_update;
non terminal    WhileStmt                while_statement;
non terminal    WhileStmtNotIf                while_statement_no_short_if;
non terminal    ReturnStmt                return_statement;
non terminal    EmptyStmt                empty_statement; //;

// evaluate the expression, if it has a value, than it's discard

non terminal    ExprStmt                expression_statement; // expression_statement = statement_expression + ;
non terminal    StmtExpr                statement_expression;
non terminal    StmtExprList                statement_expression_list; // seperate statement_expression by ','
non terminal    AssignmentExpr                assignment_expr; //
non terminal    Assignment                assignment;

// experssions (have values) and always use return value
non terminal    Expr                expr;           // any statement that returns a value
non terminal    CastExpr                cast_expr;
non terminal    ArrayAccess                array_access;
non terminal    ArrayCreationExpr                array_creation_expr;
non terminal    FieldAccess                field_access;   //{...}.ID
non terminal    ClassInstanceCreateExpr                class_instance_creation_expression;
non terminal    Primary                primary;
non terminal    PrimaryNoArray      primary_no_new_array; // simplest kinds of expressions that evaluate first
non terminal    Literal                literal;    // 123, "abc"
non terminal    MethodInvocation                method_invocation;
non terminal    UnaryExpr                unary_expr;   // -, +
non terminal    UnaryExprNotPlusMinus                unary_expr_not_plus_minus; // !, cast
non terminal    PostFixExpr                post_fix_expr;
non terminal    MultiplicativeExpr                multiplicative_expr; // *, / %
non terminal    AdditiveExpr                additive_expr;  // +, -
non terminal    RelationExpr                relation_expr;  // >, <, = instanceof
non terminal    EqualityExpr                equality_expr; // ==, !=
non terminal    AndExpr                and_expr; // &
non terminal    OrExpr                or_expr; // |
non terminal    ConditionalAndExpr                conditional_and_expr;
non terminal    ConditionalOrExpr                conditional_or_expr;
non terminal    LHS                lhs;        // left hand side: ambiguous_name, field_access, array_access
non terminal    DimExpr                dim_expr;

// parameters/arguments
non terminal    ParameterList                parameter_list;
non terminal    Parameter                paramater;
non terminal    ArgumentList                argument_list;

// Name
non terminal      Name               name;





/** Precedence */

start with compilation_unit;

/** ============= GRAMMAR ============= */

// start
compilation_unit ::= | package_decl:e1 {:RESULT = new CompilationUnit(list(e1, null, null), "");  :}
                    | import_decls:e2  {:RESULT = new CompilationUnit(list(null, e2, null), "");  :}
                    | type_decls:e3 {:RESULT = new CompilationUnit(list(null, null, e3), "");  :}
                    | package_decl:e1 import_decls:e2 {:RESULT = new CompilationUnit(list(e1, e2, null), "");  :}
                    | package_decl:e1 type_decls:e3 {:RESULT =  new CompilationUnit(list(e1, null, e3), "");  :}
                    | import_decls:e2 type_decls:e3 {:RESULT = new CompilationUnit(list(null, e2, e3), "");  :}
                    | package_decl:e1 import_decls:e2 type_decls:e3 {:RESULT = new CompilationUnit(list(e1, e2, e3), "");  :};


import_decls ::=  import_decl:e1 {:RESULT = new ImportDecls(list(e1), "");  :}
                    | import_decls:e1 import_decl:e2 {:RESULT = new ImportDecls(addList(e1, e2), "");:};

import_decl ::= single_type_import_decl:e {:RESULT = e; :}
                    | type_import_ondemand_decl:e {:RESULT = e; :};

single_type_import_decl ::= IMPORT name:e SEMICOLUMN {:RESULT = new SingleTypeImportDecl(list(e), "");:};

type_import_ondemand_decl ::= IMPORT name:e DOT STAR SEMICOLUMN {:RESULT = new TypeImportOndemandDecl(list(e), "");:};

type_decls ::=  type_decls:e1 type_decl:e2 {:RESULT = new TypeDecls(addList(e1, e2), "");:}
                | type_decl: e1 {:RESULT = new TypeDecls(list(e1), "");:};

type_decl ::= class_decl:e {:RESULT = e; :}
            | interface_decl:e {:RESULT = e; :}
            | SEMICOLUMN {:RESULT = null; :};

package_decl    ::=  PACKAGE name:e1 SEMICOLUMN {:RESULT = new PackageDecl(list(e1), ""); :};

name ::= ID:e1 {:RESULT = new Name(list(e1), "");:}
        | name:e1 DOT ID:e2 {:RESULT = new Name(addList(e1, e2), "");:};




// Statements

block ::= LEFTCURLY block_statements:e RIGHTCURLY {:RESULT = new Block(list(e), "");:}
        | LEFTCURLY RIGHTCURLY {:RESULT = new Block(list(null), "");:};

block_statements ::= block_statements:e1 block_statement:e2 {:RESULT = new BlockStmts(addList(e1, e2), "");:}
                    | block_statement:e {:RESULT = new BlockStmts(list(e), "");:};

// not sure
block_statement ::= local_var_decl_statement:e {:RESULT = e;:}
                    | statement:e {:RESULT = e;:}/**{:RESULT = new Block(list(e), "");:}*/;

local_var_decl_statement  ::= local_var_decl:e SEMICOLUMN {:RESULT = e;:};

local_var_decl  ::= type:e1 var_declarators:e2 {:RESULT = new LocalVarDecl(list(e1, e2), "");:};
/**
 * Parser/weeder:
 * - Multiple variable in same declaration not allowed.
 */
var_declarators ::= var_declarator:e  {:RESULT = new VarDeclarators(list(e), "");:};
                    //| var_declarators:e1 COMMA var_declarator:e2 {:RESULT = new VarDeclarators(addList(e1, e2), "");:};

var_declarator ::= var_declarator_id:e {:RESULT = new VarDeclarator(list(e, null), "");:}
                    | var_declarator_id:e1 ASSIGN expr:e2 {:RESULT = new VarDeclarator(list(e1, e2), "");:};

var_declarator_id ::= ID:e {:RESULT = new VarDeclaratorID(list(e), "");:};

statement ::= statement_without_trailing_substatement:e {:RESULT = e;:}
            | if_then_statement:e {:RESULT = e;:}
            | if_then_else_statement:e {:RESULT = e;:}
            | while_statement:e {:RESULT = e;:}
            | for_statement:e {:RESULT = e;:};

statement_without_trailing_substatement ::= block:e {:RESULT = e;:}   // single statement
                                            | empty_statement:e {:RESULT = e;:}
                                            | expression_statement:e {:RESULT = e;:}
                                            | return_statement:e {:RESULT = e;:};

statement_no_short_if ::= statement_without_trailing_substatement:e {:RESULT = new StmtNotIf(list(e), "");:}
                        | if_then_else_statement_no_short_if:e {:RESULT = e;:}
                        | while_statement_no_short_if:e {:RESULT = e;:}
                        | for_statement_no_short_if:e {:RESULT = e;:};

empty_statement ::= SEMICOLUMN {:RESULT = new EmptyStmt(list(), "");:};
// not sure
expression_statement ::= statement_expression:e SEMICOLUMN {:RESULT = new ExprStmt(list(e), "");:};

statement_expression ::= assignment:e {:RESULT = new StmtExpr(list(e), "");:}
                        | method_invocation:e {:RESULT = new StmtExpr(list(e), "");:}
                        | class_instance_creation_expression:e {:RESULT = new StmtExpr(list(e), "");:};


// if statement

if_then_statement ::= IF LEFTPARN expr:e1 RIGHTPARN statement:e2 {:RESULT = new IfThenStmt(list(e1, e2), "");:};

if_then_else_statement ::= IF LEFTPARN expr:e1 RIGHTPARN statement_no_short_if:e2 ELSE statement:e3 {:RESULT = new IfThenElseStmt(list(e1, e2, e3), "");:};

if_then_else_statement_no_short_if ::= IF LEFTPARN expr:e1 RIGHTPARN statement_no_short_if:e2 ELSE statement_no_short_if:e3 {:RESULT = new IfThenElseStmtNotIf(list(e1, e2, e3), "");:};

// while statement
while_statement ::= WHILE LEFTPARN expr:e1 RIGHTPARN statement:e2 {:RESULT = new WhileStmt(list(e1, e2), "");:};

while_statement_no_short_if ::= WHILE LEFTPARN expr:e1 RIGHTPARN statement_no_short_if:e2 {:RESULT = new WhileStmtNotIf(list(e1, e2), "");:};

// for statement
for_statement ::= FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(null, null, null, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(e1, null, null, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN expr:e2  SEMICOLUMN  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(null, e2, null, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN for_update:e3  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(null, null, e3, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN expr:e2  SEMICOLUMN  RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(e1, e2, null, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN  SEMICOLUMN for_update:e3 RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(e1, null, e3, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN expr:e2 SEMICOLUMN for_update:e3 RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(null, e2, e3, e4), "");:}
                | FOR LEFTPARN for_init:e1  SEMICOLUMN expr:e2 SEMICOLUMN for_update:e3 RIGHTPARN statement:e4 {:RESULT = new ForStmt(list(e1, e2, e3, e4), "");:};

for_statement_no_short_if ::= FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(null, null, null, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN  SEMICOLUMN  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(e1, null, null, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN expr:e2  SEMICOLUMN  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(null, e2, null, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN  SEMICOLUMN for_update:e3  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(null, null, e3, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN expr:e2  SEMICOLUMN  RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(e1, e2, null, e4), "");:}
                | FOR LEFTPARN for_init:e1 SEMICOLUMN  SEMICOLUMN for_update:e3 RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(e1, null, e3, e4), "");:}
                | FOR LEFTPARN  SEMICOLUMN expr:e2 SEMICOLUMN for_update:e3 RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(null, e2, e3, e4), "");:}
                | FOR LEFTPARN for_init:e1  SEMICOLUMN expr:e2 SEMICOLUMN for_update:e3 RIGHTPARN statement_no_short_if:e4 {:RESULT = new ForStmtNotIf(list(e1, e2, e3, e4), "");:};

for_init ::=  type:e1 var_declarator:e2 {:RESULT = new ForInit(list(e1, e2), "");:}
            | statement_expression:e1 {:RESULT = new ForInit(list(e1, null), "");:};

for_update ::=  statement_expression:e {:RESULT = new ForUpdate(list(e), "");:};

statement_expression_list ::= statement_expression:e {:RESULT = new StmtExprList(list(e), "");:}
                            | statement_expression_list:e1 COMMA statement_expression:e2 {:RESULT = new StmtExprList(addList(e1, e2), "");:};

return_statement ::= RETURN expr:e SEMICOLUMN {:RESULT = new ReturnStmt(list(e), "");:}
                    | RETURN SEMICOLUMN {:RESULT = new ReturnStmt(list(null), "");:};

// expressions
dim_expr ::= LEFTBRACKET expr:e RIGHTBARCKET {:RESULT = new DimExpr(list(e), "");:};

primary ::= primary_no_new_array:e {:RESULT = e;:}
            | array_creation_expr:e {:RESULT = e;:};

array_creation_expr ::= NEW primitive_type:e1 dim_expr:e2 {:RESULT = new ArrayCreationExpr(list(e1, e2), "");:}
                    |  NEW class_or_interface_type:e1 dim_expr:e2 {:RESULT = new ArrayCreationExpr(list(e1, e2), "");:};



primary_no_new_array ::= literal:e {:RESULT = e;:}
                         | THISLITERAL:e {:RESULT = new PrimaryNoArray(list(e), "");:}
                         | LEFTPARN expr:e RIGHTPARN {:RESULT = new PrimaryNoArray(list(e), "");:}
                         | class_instance_creation_expression:e {:RESULT = e;:}
                         | field_access:e {:RESULT = e;:}
                         | method_invocation:e {:RESULT = e;:}
                         | array_access:e {:RESULT = e;:};


numeric_literal ::= INTGERLITERAL:e {:RESULT = new NumericLiteral(list(e), "");:};

literal ::= numeric_literal:e {:RESULT = e;:}
            | TRUELITERAL:e {:RESULT = new Literal(list(e), "");:}
            | FALSELITERAL:e {:RESULT = new Literal(list(e), "");:}
            | CHARLITERAL:e {:if (NotCorrectEscapeChar(e)) throw new Exception("Syntax Error");
            else RESULT = new Literal(list(e), "");:}
            | STRINGLITERAL:e {: if (NotCorrectEscapeString(e)) throw new Exception("Syntax Error");
            else RESULT = new Literal(list(e), "");:}
            | NULLLITERAL:e {:RESULT = new Literal(list(e), "");:};

class_instance_creation_expression ::= NEW class_or_interface_type:e1 LEFTPARN argument_list:e2 RIGHTPARN {:RESULT = new ClassInstanceCreateExpr(list(e1, e2), "");:}
                                    |  NEW class_or_interface_type:e1 LEFTPARN RIGHTPARN {:RESULT = new ClassInstanceCreateExpr(list(e1, null), "");:};

argument_list ::=  expr:e1 {:RESULT = new ArgumentList(list(e1), "");:}
                | argument_list:e1 COMMA expr:e2 {:RESULT = new ArgumentList(addList(e1, e2), "");:};


array_access ::= name:e1 dim_expr:e2 {:RESULT = new ArrayAccess(list(e1, e2), "");:}
                | primary_no_new_array:e1 dim_expr:e2 {:RESULT = new ArrayAccess(list(e1, e2), "");:};

field_access ::= primary:e1 DOT ID:e2 {:RESULT = new FieldAccess(list(e1, e2), "");:};

method_invocation ::= name:e1 LEFTPARN argument_list:e3 RIGHTPARN {:checkInvalidMethodName(e1); RESULT = new MethodInvocation(list(e1, null, e3), "");:}
                    | name:e1 LEFTPARN  RIGHTPARN {:checkInvalidMethodName(e1); RESULT = new MethodInvocation(list(e1, null, null), "");:}
                    | primary:e1 DOT ID:e2 LEFTPARN argument_list:e3 RIGHTPARN {:RESULT = new MethodInvocation(list(e1, e2, e3), "");:}
                    | primary:e1 DOT ID:e2 LEFTPARN  RIGHTPARN {:RESULT = new MethodInvocation(list(e1, e2, null), "");:};
// Not sure for the 3 below
post_fix_expr ::= primary:e {:RESULT = e;:}
                  | name:e {:RESULT = new PostFixExpr(list(e), "");:};

unary_expr  ::=  unary_expr_not_plus_minus:e {:RESULT = e;:}
                | MINUS:e1 unary_expr:e2 {:setNumberBound(e2, 2147483648l);RESULT = new UnaryExpr(list(e1, e2), "");:};

unary_expr_not_plus_minus   ::= NOT:e1 unary_expr:e2 {:RESULT = new UnaryExprNotPlusMinus(list(e1, e2), "");:}
                            |   cast_expr:e {:RESULT = e;:}
                            | post_fix_expr:e {:RESULT = e;:};

cast_expr   ::= LEFTPARN primitive_type:e1 RIGHTPARN unary_expr:e3 {:RESULT = new CastExpr(list(e1, null, e3), "");:}
                | LEFTPARN expr:e1 RIGHTPARN unary_expr_not_plus_minus:e3 {:if (IncorrectCastExpr(e1)) throw new Exception("Syntax Error");
                else RESULT = new CastExpr(list(e1, null, e3), "");:}
                | LEFTPARN primitive_type:e1 dims:e2 RIGHTPARN unary_expr:e3 {:RESULT = new CastExpr(list(e1, e2, e3), "");:}
                | LEFTPARN name:e1 dims:e2 RIGHTPARN unary_expr_not_plus_minus:e3 {:RESULT = new CastExpr(list(e1, e2, e3), "");:};

multiplicative_expr ::= unary_expr:e {:setNumberBound(e, 2147483647l); RESULT = e;:}
                    |   multiplicative_expr:e1 STAR:e2 unary_expr:e3 {:RESULT = new MultiplicativeExpr(list(e1, e2, e3), "");:}
                    |   multiplicative_expr:e1 DIVIDES:e2 unary_expr:e3 {:RESULT = new MultiplicativeExpr(list(e1, e2, e3), "");:}
                    |   multiplicative_expr:e1 MOD:e2 unary_expr:e3 {:RESULT = new MultiplicativeExpr(list(e1, e2, e3), "");:};

additive_expr ::= multiplicative_expr:e {:RESULT = e;:}
                | additive_expr:e1 PLUS:e2 multiplicative_expr:e3 {:RESULT = new AdditiveExpr(list(e1, e2, e3), "");:}
                | additive_expr:e1 MINUS:e2 multiplicative_expr:e3 {:RESULT = new AdditiveExpr(list(e1, e2, e3), "");:};

relation_expr ::= additive_expr:e {:RESULT = e;:}
                | relation_expr:e1 LT:e2 additive_expr:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:}
                | relation_expr:e1 GT:e2 additive_expr:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:}
                | relation_expr:e1 LE:e2 additive_expr:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:}
                | relation_expr:e1 GE:e2 additive_expr:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:}
                | relation_expr:e1 INSTANCEOF:e2 reference_type:e3 {:RESULT = new RelationExpr(list(e1, e2, e3), "");:};

equality_expr ::= relation_expr:e {:RESULT = e;:}
                | equality_expr:e1 EQ:e2 relation_expr:e3 {:RESULT = new EqualityExpr(list(e1, e2, e3), "");:}
                | equality_expr:e1 NE:e2 relation_expr:e3 {:RESULT = new EqualityExpr(list(e1, e2, e3), "");:};

and_expr ::= equality_expr:e {:RESULT = e;:}
            | and_expr:e1 BITWISEAND equality_expr:e2 {:RESULT = new AndExpr(list(e1, e2), "");:};

or_expr ::= and_expr:e {:RESULT = e;:}
          | or_expr:e1 BITWISEOR and_expr:e2 {:RESULT = new OrExpr(list(e1, e2), "");:};

conditional_and_expr ::= or_expr:e {:RESULT = e;:}
                        | conditional_and_expr:e1 BINARYAND or_expr:e2 {:RESULT = new ConditionalAndExpr(list(e1, e2), "");:};

conditional_or_expr ::= conditional_and_expr:e {:RESULT = e;:}
                        | conditional_or_expr:e1 BINARYOR conditional_and_expr:e2 {:RESULT = new ConditionalOrExpr(list(e1, e2), "");:};

assignment_expr ::= conditional_or_expr:e {:RESULT = e;:}
                |   assignment:e {:RESULT = e;:};

assignment ::= lhs:e1 ASSIGN assignment_expr:e2 {:RESULT = new Assignment(list(e1, e2), "");:};

lhs ::= name:e {:RESULT = new LHS(list(e), "");:}
        | field_access:e {:RESULT = new LHS(list(e), "");:}
        | array_access:e {:RESULT = new LHS(list(e), "");:};

expr ::= assignment_expr:e {:RESULT = e;:};


// type
dims ::= LEFTBRACKET RIGHTBARCKET;

type ::= primitive_type:e {:RESULT = e;:}
        | reference_type:e {:RESULT = e;:};



primitive_type ::= numeric_type:e {:RESULT = e;:}
                 | BOOL:e {:RESULT = new PrimitiveType(list(), e.value);:};

numeric_type ::= BYTE:e {:RESULT = new NumericType(list(e), e.value);:}
                | SHORT:e {:RESULT = new NumericType(list(), e.value);:}
                | INT:e {:RESULT = new NumericType(list(), e.value);:}
                | CHAR:e {:RESULT = new NumericType(list(), e.value);:};

reference_type ::= class_or_interface_type:e {:RESULT = e;:}
                |  array_type:e {:RESULT = e;:};

class_or_interface_type ::= name:e {:RESULT = new ClassOrInterfaceType(list(e), "");:};

class_type ::= class_or_interface_type:e {:RESULT = e;:};
interface_type ::= class_or_interface_type:e {:RESULT = e;:};

array_type ::= name:e dims  {:RESULT = new ArrayType(list(new ClassOrInterfaceType(list(e), "")), "");:}
            |  primitive_type:e dims {:RESULT = new ArrayType(list(e), "");:};


// class and interface
modifier ::= PUBLIC:e {:RESULT = e;:}
        | PROTECTED:e {:RESULT = e;:}
        | ABSTRACT:e {:RESULT = e;:}
        | NATIVE:e {:RESULT = e;:}
        | FINAL:e {:RESULT = e;:}
        | STATIC:e {:RESULT = e;:};

modifiers ::= modifier:e {:RESULT = new Modifiers(list(e), "");:}
           | modifiers:e1 modifier:e2 {:RESULT = new Modifiers(addList(e1,e2), "");:};

// class
// class modifier: public protected  abstract static final
class_decl ::= modifiers:e1 CLASS ID:e2 class_body:e5 {:checkModifiers(e1); checkInvalidFileName(e1, e2); if (NotClassModifier(e1)) throw new Exception("Syntax Error");
               else RESULT = new ClassDecl(list(e1, e2, null, null, e5), "");:}
               |
               modifiers:e1 CLASS ID:e2 Super:e3 class_body:e5 {:checkModifiers(e1); checkInvalidFileName(e1, e2); if (NotClassModifier(e1)) throw new Exception("Syntax Error");
               else RESULT = new ClassDecl(list(e1, e2, e3, null, e5), "");:}
               |
               modifiers:e1 CLASS ID:e2 interfaces:e4 class_body:e5 {:checkInvalidFileName(e1, e2); if (NotClassModifier(e1)) throw new Exception("Syntax Error");
               else RESULT = new ClassDecl(list(e1, e2, null, e4, e5), "");:}
               |
               modifiers:e1 CLASS ID:e2 Super:e3 interfaces:e4 class_body:e5 {:checkInvalidFileName(e1, e2); if (NotClassModifier(e1)) throw new Exception("Syntax Error");
               else RESULT = new ClassDecl(list(e1, e2, e3, e4, e5), "");:}
               ;


interface_decl ::= modifiers:e1 INTERFACE ID:e2 interface_body:e4 {:checkModifiers(e1); checkInvalidFileName(e1, e2); if (NotInterfaceModifier(e1)) throw new Exception("Syntax Error");
                   else RESULT = new InterfaceDecl(list(e1, e2, null, e4), "");:}
                   |
                   modifiers:e1 INTERFACE ID:e2 extends_interfaces:e3 interface_body:e4 {:checkModifiers(e1); checkInvalidFileName(e1, e2); if (NotInterfaceModifier(e1)) throw new Exception("Syntax Error");
                   else RESULT = new InterfaceDecl(list(e1, e2, e3, e4), "");:}
                   ;

extends_interfaces ::= EXTENDS interface_type:e {:RESULT = new ExtendsInterfaces(list(e), "");:}
                    |  extends_interfaces:e1 COMMA interface_type:e2 {:RESULT = new ExtendsInterfaces(addList(e1,e2), "");:};

Super ::= EXTENDS class_type:e {:RESULT = new Super(list(e), "");:};

interfaces ::= IMPLEMENTS  interface_typelist:e {:RESULT = new Interfaces(list(e), "");:};

interface_typelist ::= interface_type:e {:RESULT = new InterfaceTypeList(list(e), "");:}
                       |
                       interface_typelist:e1 COMMA interface_type:e2 {:RESULT = new InterfaceTypeList(addList(e1,e2), "");:}
                       ;


class_body ::= LEFTCURLY class_body_decls:e RIGHTCURLY {:checkConstructorDecl(e); RESULT = new ClassBody(list(e), "");:}
               |
               LEFTCURLY RIGHTCURLY {:RESULT = new ClassBody(list(null), "");:}
               ;

class_body_decls ::= class_body_decl:e {:RESULT = new ClassBodyDecls(list(e), "");:}
                     |
                     class_body_decls:e1 class_body_decl:e2 {:RESULT = new ClassBodyDecls(addList(e1,e2), "");:}
                     ;

class_body_decl ::= class_member_decl:e {:RESULT = e;:}
                    |
                    constructor_decl:e {:RESULT = e;:}
                    ;

class_member_decl ::= field_decl:e {:RESULT = e;:}
                      |
                      method_decl:e {:RESULT = e;:}
                      ;

constructor_decl ::= modifiers:e1 constructor_declarator:e2 constructor_body:e3 {:checkModifiers(e1);  if (NotConstructorModifier(e1)) throw new Exception("Syntax Error");
                    else RESULT = new ConstructorDecl(list(e1,e2,e3),"");:}
                     ;

field_decl ::= modifiers:e1 type:e2 var_declarators:e3 SEMICOLUMN {:checkModifiers(e1); if (NotFieldModifier(e1)) throw new Exception("Syntax Error");
                else RESULT = new FieldDecl(list(e1,e2,e3), "");:};

// adding in 8.4
// is this delcaration or declarator cuz abstract_method_decl asking for declarator
method_decl ::= method_header:e1 method_body:e2 {:checkInvalidMethodBody(e1, e2);RESULT = new MethodDecl(list(e1,e2), "");:}; //TODO: replace null with e3
method_header ::=  modifiers:e1 type:e2 method_declarator:e3 {:checkModifiers(e1); if (NotMethodModifier(e1)) throw new Exception("Syntax Error");
                else RESULT = new MethodHeader(list(e1,e2, e3), "");:}
                |  modifiers:e1 VOID:e2 method_declarator:e3 {:checkModifiers(e1); if (NotMethodModifier(e1)) throw new Exception("Syntax Error");
                else RESULT = new MethodHeader(list(e1,e2, e3), "");:};

method_body ::= block:e  {:RESULT = new MethodBody(list(e), "");:} //TODO: replace null with e
                | SEMICOLUMN {:RESULT = new MethodBody(list(null), "");:};


method_declarator ::= ID:e1 LEFTPARN parameter_list:e2 RIGHTPARN {:RESULT = new MethodDeclarator(list(e1, e2), "");:}
                    | ID:e1 LEFTPARN RIGHTPARN {:RESULT = new MethodDeclarator(list(e1, null), "");:};

parameter_list ::=  paramater:e {:RESULT = new ParameterList(list(e), "");:}
                   | parameter_list:e1 COMMA paramater:e2 {:RESULT = new ParameterList(addList(e1, e2), "");:};

paramater ::= type:e1 var_declarator_id:e2 {:RESULT = new Parameter(list(e1, e2), "");:};


abstract_method_decl ::= modifiers:e1 type:e2 method_declarator:e3 {:checkModifiers(e1); if (NotAbstractMethodModifier(e1)) throw new Exception("Syntax Error");
                    else RESULT = new AbstractMethodDecl(list(e1, e2, e3), "");:};


interface_body ::= LEFTCURLY interface_member_decls:e RIGHTCURLY {:RESULT = new InterfaceBody(list(e), "");:}
                   |
                   LEFTCURLY RIGHTCURLY {:RESULT = new InterfaceBody(list(null), "");:}
                   ;

interface_member_decls ::= interface_member_decl:e {:RESULT = new InterfaceMemberDecls(list(e), "");:}
                           |
                           interface_member_decls:e1 interface_member_decl:e2 {:RESULT = new InterfaceMemberDecls(addList(e1,e2), "");:}
                           ;
interface_member_decl ::= abstract_method_decl:e  {:RESULT = e;:}
                          ;


constructor_declarator ::= ID:e1 LEFTPARN parameter_list:e2 RIGHTPARN {:RESULT = new ConstructorDeclarator(list(e1, e2), "");:}
                           |
                           ID:e1 LEFTPARN RIGHTPARN {:RESULT = new ConstructorDeclarator(list(e1, null), "");:}
                           ;
constructor_body ::= LEFTCURLY block_statements:e RIGHTCURLY {:RESULT = new ConstructorBody(list(e), "");:}
                     |
                     LEFTCURLY RIGHTCURLY {:RESULT = new ConstructorBody(list(null), "");:};


